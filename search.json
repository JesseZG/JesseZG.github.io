[{"title":"【Python】Python + Scipy + Matplotlib 实现任意一元函数拟合","path":"/posts/3950149617/","content":"前言 之前在大学组织里面参加校内举办的智能汽车竞赛，顺便用 Python 研究了下一元函数拟合。虽然没用到，但闲着没事的时候用 Tkinter 封装好了程序。本文大致介绍一些程序设计的思路，因为文件太大不适合在 Github 上部署，所以在最后附上了源代码。因为博主是 Python 初学者，所以无论是算法方面还是逻辑方面可能都会有可以优化的地方，有建议可以通过邮箱 z12502793@163.com 反馈。 工具介绍 Python Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，具有良好的可移植性和可扩展性，最初被设计用于编写自动化脚本(shell)。随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发，在科学计算、人工智能、Web开发、网络爬虫、数据分析等领域都有广泛的应用。 Numpy 和 Scipy Numpy 和 Scipy 是Python的两个科学计算库。Numpy 提供了数组对象，以及许多用于操作这些数组的函数；Scipy 是一个用于科学计算的 Python 库，它包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。Numpy 和 Scipy 的协同工作可以高效解决很多问题，在人工智能、数据分析等众多领域中得到了广泛应用。 Matplotlib 和 Pyplot Matplotlib 是 Python 的一个绘图库，它能提供多样化的输出格式实现数据可视化。Pyplot 是 Matplotlib 的子库，提供了和 MATLAB 类似的绘图API，是 Python 常用的绘图模块，能很方便绘制函数图像或统计图。 Tkinter Tkinter 提供了多种控件，如按钮，标签，文本框等，以及标准属性和方法，如大小，颜色，字体等，是Python的标准Tk GUI工具包的接口。 代码 没有用 Tkinter 打包的拟合原代码 123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, b, c): return b*x + c# 输入要拟合的x,y的值的原始数据x = np.array([600,700, 800, 900,1000,1100,1200,1300,1400])y = np.array([800,900,1000,1100,1200,1200,1300,1400,1490])#进行函数拟合,abcd为输出函数参数，para为拟合效果参数abcd, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(abcd)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)# 后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况predict_past = 100predict_future = 100#将拟合的函数转换成函数图像微分形式X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000)Y = f(X, *abcd)#绘制拟合前数据点图效果和拟合后函数图像效果fig, ax = plt.subplots()ax.set_title(&quot;function fitting curve&quot;)ax.set_xlabel(&quot;right_speed&quot;)ax.set_ylabel(&quot;left_speed&quot;)ax.scatter(x, y)ax.plot(X, Y, color=&quot;r&quot;)plt.show() Tkinter 封装后的代码 使用方法 在 Python 环境下运行文件，在第一行中选择要拟合的变量数，第二行输入要拟合成的函数表达式（表达式为函数x侧的多项式，用 Python 数学表达式的方法表示，参数从 a 开始，数量要与要拟合的参数数保持对应；例如要拟合的函数为普通二次函数,应输入ax**2+bx+c）。 第三、四行输入要拟合的 x, y 变量的原始值，必须要一一对应，数量不能少于拟合参数数量，两个数字之间用逗号分隔。 第五行输入拟合效果图像中变量 x, y 多余的范围，例如如果要拟合二次函数输入的 x 的初始值为 1, 2, 3; 输入的 y 的初始值为 1, 4, 9; 如果需要查看图像x，y的范围均为1，则展示拟合曲线在 x=[0,4] 范围的二次曲线。如果不需要则都应该写成0,不写程序会报错。 第六行点击后即可执行程序，在右边会出现拟合函数图像，下面会出现很多个参数，依次是 a, b, c… 的拟合参数。 如果程序报错提示找不到 Numpy, Scipy, Tkinter, Matplotlib 等第三方库则需要在终端中输入 pip install 【需要的模块名】 下载对应模块。 其他报错可能是输入的问题，检查是否严格按照此处所写的使用方法执行。如果未能发现问题可以向邮箱 z12502793@163.com 进行反馈。博主只是一个爱好编程的大学生，如果发现其他 bug、优化方案也可以通过邮箱向博主提建议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186import tkinter as tkfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAggimport matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as opimport sys# 定义拟合函数，每种对应一种参数数量def f1(x, a): return eval(entry1.get())def f2(x, a, b): return eval(entry1.get())def f3(x, a, b, c): return eval(entry1.get())def f4(x, a, b, c, d): return eval(entry1.get())def f5(x, a, b, c, d, e): return eval(entry1.get())def f6(x, a, b, c, d, e, f): return eval(entry1.get())def f7(x, a, b, c, d, e, f, g): return eval(entry1.get())def f8(x, a, b, c, d, e, f, g, h): return eval(entry1.get())# 按下按钮后执行def start(): # 清除画布上所有东西 for widget in frame_canva.winfo_children(): widget.destroy() # 要拟合的x,y的值的原始数据 x = eval(&quot;np.array([&quot; + entry2.get() + &quot;])&quot;) y = eval(&quot;np.array([&quot; + entry3.get() + &quot;])&quot;) #对每一种参数数量进行函数拟合,abcd为输出函数参数，para为拟合效果参数 if radio_value.get() == 1: abcd, para = op.curve_fit(f1, x, y) if radio_value.get() == 2: abcd, para = op.curve_fit(f2, x, y) if radio_value.get() == 3: abcd, para = op.curve_fit(f3, x, y) if radio_value.get() == 4: abcd, para = op.curve_fit(f4, x, y) if radio_value.get() == 5: abcd, para = op.curve_fit(f5, x, y) if radio_value.get() == 6: abcd, para = op.curve_fit(f6, x, y) if radio_value.get() == 7: abcd, para = op.curve_fit(f7, x, y) if radio_value.get() == 8: abcd, para = op.curve_fit(f8, x, y) # 将abcd打印出来替换原来的text6 text6 = tk.Label(frame_value, text=abcd) text6.grid(row=9, column=0, columnspan=2) # 后面都是用来看拟合图像效果的 #这个两参数用于预测拟合图像在给的值之前和之后的发展情况 predict_past = eval(&quot;np.array(&quot; + entry4.get() + &quot;)&quot;) predict_future = eval(&quot;np.array(&quot; + entry5.get() + &quot;)&quot;) #将拟合的函数转换成函数图像微分形式 X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000) if radio_value.get() == 1: Y = f1(X, *abcd) if radio_value.get() == 2: Y = f2(X, *abcd) if radio_value.get() == 3: Y = f3(X, *abcd) if radio_value.get() == 4: Y = f4(X, *abcd) if radio_value.get() == 5: Y = f5(X, *abcd) if radio_value.get() == 6: Y = f6(X, *abcd) if radio_value.get() == 7: Y = f7(X, *abcd) if radio_value.get() == 8: Y = f8(X, *abcd) #绘制拟合前数据点图效果和拟合后函数图像效果# --------------------------------------------------------# 这段是画图像的，但不知道具体在干嘛，以后可以研究研究 fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例 f_plot =fig.add_subplot(111)#划分区域 canvas = FigureCanvasTkAgg(fig,frame_canva) canvas.get_tk_widget().pack()#放置位置 plt.scatter(x, y) plt.plot(X, Y, color=&quot;r&quot;)# -------------------------------------------------------# 创建窗口window = tk.Tk()window.title(&quot;Fitting_curve&quot;)#定义四个框架，其中radio和value框架在frame里面，canva与frame并列frame = tk.Frame(window, width=150, height=80, borderwidth=5)frame_radio = tk.Frame(frame, width=150, height=80, borderwidth=5)frame_value = tk.Frame(frame, width=150, height=300, borderwidth=5)frame_canva = tk.Frame(window, width=150, height=400, borderwidth=5)# 定义radio框架中的内容text0 = tk.Label(frame_radio, text=&quot;参量数：&quot;)radio_value = tk.IntVar()radio1 = tk.Radiobutton(frame_radio, text=1, value=1, variable=radio_value)radio2 = tk.Radiobutton(frame_radio, text=2, value=2, variable=radio_value)radio3 = tk.Radiobutton(frame_radio, text=3, value=3, variable=radio_value)radio4 = tk.Radiobutton(frame_radio, text=4, value=4, variable=radio_value)radio5 = tk.Radiobutton(frame_radio, text=5, value=5, variable=radio_value)radio6 = tk.Radiobutton(frame_radio, text=6, value=6, variable=radio_value)radio7 = tk.Radiobutton(frame_radio, text=7, value=7, variable=radio_value)radio8 = tk.Radiobutton(frame_radio, text=8, value=8, variable=radio_value)#定义value框架中的内容text1 = tk.Label(frame_value, text=&quot;输入要拟合成的函数表达式&quot;)entry1 = tk.Entry(frame_value, width= 50)text2 = tk.Label(frame_value, text=&quot;输入要拟合的x变量&quot;)entry2 = tk.Entry(frame_value, width= 50)text3 = tk.Label(frame_value, text=&quot;输入要拟合的y变量&quot;)entry3 = tk.Entry(frame_value, width= 50)text4 = tk.Label(frame_value, text=&quot;输入要预测的x变量范围&quot;)entry4 = tk.Entry(frame_value, width= 25)text5 = tk.Label(frame_value, text=&quot;输入要预测的y变量范围&quot;)entry5 = tk.Entry(frame_value, width= 25)text6 = tk.Label(frame_value, text=&quot;&quot;)button = tk.Button(frame_value, text=&quot;开始拟合&quot;, command=start, pady=3)# 将radio和value一依次放在frame的上面frame_radio.pack(side=&quot;top&quot;)frame_value.pack(side=&quot;top&quot;)# 将radio中的东西用grid放置text0.grid(row=0, column=0)radio1.grid(row=0, column=1)radio2.grid(row=0, column=2)radio3.grid(row=0, column=3)radio4.grid(row=0, column=4)radio5.grid(row=0, column=5)radio6.grid(row=0, column=6)radio7.grid(row=0, column=7)radio8.grid(row=0, column=8)# 将value中的东西用grid放置text1.grid(row=0, column=0, columnspan=2)entry1.grid(row=1, column=0, columnspan=2,)text2.grid(row=2, column=0, columnspan=2)entry2.grid(row=3, column=0, columnspan=2)text3.grid(row=4, column=0, columnspan=2)entry3.grid(row=5, column=0, columnspan=2)text4.grid(row=6, column=0)entry4.grid(row=7, column=0)text5.grid(row=6, column=1)entry5.grid(row=7, column=1)text6.grid(row=9, column=0, columnspan=2)button.grid(row=8, column=0, columnspan=2)# 将frame和canva两个框架依次放在左边frame.pack(side=&quot;left&quot;)frame_canva.pack(side=&quot;left&quot;)# 在刚打开文件时还没有图像，这一段用来在刚打开文件时放一个图像fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例f_plot =fig.add_subplot(111)#划分区域canvas = FigureCanvasTkAgg(fig,frame_canva)canvas.get_tk_widget().pack()#放置位置# 监测是否关掉窗口，关掉后结束程序window.protocol(&quot;WM_DELETE_WINDOW&quot;, lambda: sys.exit())# 主循环window.mainloop() 研究用：二元函数拟合 这个程序是博主和 Chatgpt 搞了一整天才实现的，依旧是通过 Scipy.optimize 实现二次函数拟合。程序中很多地方博主依旧不明白是怎么实现的，但是因为勉强可以用所以也发到这篇文章中了。这个程序还在研发中所以可能有很多 Bug，如果发现可以修改的地方可以通过邮箱z12502793@163.com 告诉博主。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, a, b, c, d, e): return a*x[0]**2 + b*x[0] + c*x[1]**2 + d*x[1] + e# 输入要拟合的x1, x2, y的值的原始数据, x1的格式与y横行长度相同，x2的格式与y竖行长度相同x1 = (1, 2, 3, 4, 5, 6)x2 = (1, 2, 3, 4, 5)y = np.array([[3, 10, 21, 36, 55, 78], [4, 11, 22, 37, 56, 79], [5, 12, 23, 38, 57, 80], [6, 13, 24, 39, 58, 81], [7, 14, 25, 40, 59, 82]])# x1, x2, y整理形式进行函数拟合x1, x2 = np.meshgrid(x1, x2)x = np.vstack((x1.flatten(), x2.flatten()))y = y.flatten()abc, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(*abc)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)#后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况x1_past = 3x1_future = 3x2_past = 3x2_future = 3# #将拟合的函数转换成函数图像微分形式X1 = np.linspace(x1[0, 0] - x1_past, x1[0, -1] + x1_future, 101) # 创建非周期性网格X2 = np.linspace(x2[0, 0] - x2_past, x2[-1, 0] + x2_future, 101) # 创建非周期性网格X = np.meshgrid(X1, X2)Y = (f(X, *abc))#绘制拟合前数据点图效果和拟合后函数图像效果ax = plt.subplot(projection=&quot;3d&quot;)ax.scatter(x[0], x[1], y, color=&quot;black&quot;)ax.plot_surface(X[0], X[1], Y, cmap=&quot;rainbow&quot;)ax.set_xlabel(&quot;x1&quot;)ax.set_ylabel(&quot;x2&quot;)ax.set_zlabel(&quot;y&quot;)plt.show()","tags":["数学","Python"],"categories":["程序","Python"]},{"title":"【博客维护】博客建设日志","path":"/posts/3847924491/","content":"网站建设历史 2023-11-26 通过 Hexo 的 Chic 主题完成网站搭建，上传了第一篇文章。 2023-11-27 改用 Hexo 的 Stellar 主题，完成了博客的 about 部分。 2023-12-01 创建博客建设日志。 2023-12-03 创建分类目录，创建博客的五种分类。 2023-12-08 将网站最初的日记目录更改为 abbr 目录，防止未来出现死链；将解释器从 pandoc 改为 renderer-markdown-it。 2023-12-08 修改了网站的 css，加上了 id 为 tips, success, warning, danger 的样式，用于自定义盒子。 2023-12-12 统一 Markdown 文档的文件格式。 2024-03-15 重新启动博客。 2024-08-02 修改内容。 网站建设心路 2023-12-08 最开始我建这个网站觉得只要建好了就很容易写文章了，但我却不愿意写不太全面的，也不太知道些什么，都过了半个月了博客里面还是空空的，只有一些我自己类似于学习笔记的东西，其他的大概都布置的差不多了。船舰这个博客的过程中我遇到了好多问题，大多数都要么解决了，要么还在留着，要么藏起来了。其实这个博客的搭建到完善只是一个过程，等我大学毕业之后如果 JS 的东西学的还不错的话会自己去找一个服务器，从 HTML 开始一点一点搭建一整个博客，这是我学前端最早的目标，虽然很难但我也应该坚持。也许我只是太闲了没事干吧。 2024-03-15 我越来越迷茫了，不知道应不应该在 web 方向继续发展。其实我更希望能够在 Python 人工智能，算法方向进行研究，会搞 web 主要是因为我太孤独希望大家能看到我。如果我不做任何宣传，也不以这个作为工作的话的话其实也没什么用，所以我其实早就失去了学习 web 的理由了。以后会以 Python 的学习为主，但之前建了这个博客就尽量维护吧，把这里当成一个大号笔记，或许能让我整理一些思路。 2024-8-02 把所有文章都删掉了，也删掉了很多和个人信息有关的内容。以后打算把这个博客改造成类似于学习笔记的东西，也可以写一些我的作品，创作的历程。上大学以来给我最大的感觉就是知识太繁杂了，如果不是静下心来慢慢学的话再怎么努力也只能涉及到皮毛。既然我这么不专心，就没必要把这些东西弄得太深入了，只是为了玩而研究同样很有趣。 网站建设未解决的问题 头像 因为有一个博客，所以也想要设计一个头像。头像我打算找时间设计一个独特一点的，因为还没有真的动手去做，所以不知道做好是什么样的呢，总之先留着吧。 动态网站因为 GitHub 上好像只能写 1 GB 的文件，所以我要是一直这么加东西的话早晚会有网站过大的一天。而且是 GitHub 上部署的文件没有数据库，所以没办法获得访问者的数量、情报、评论什么的，因此现在看来或许我可以把我的文章多在这上面存着，但这不是什么长久的计策。我大学毕业前要是一直能用的话就等到大学毕业再试着改成动态网站吧。虽然动态网站对我来说实在是太难搞了，但一点一点学总会有进步的。 社交 因为我暂时没有能够分享博客的朋友，所以无论是留言板还是友链都是空的，会跳转到 404 。我觉得这个博客还没发展到可以直接分享，还需要更多文章撑起来内容，所以这些以后再弄吧。","tags":["博客维护"],"categories":["博客维护"]},{"title":"about","path":"/about/index.html","content":"有关博客 欢迎来到 JesseZG 的小破站！在博客中会记录一些博主的作品、学习笔记和学习历程。 本站由 Hexo 的 stellar 制作搭建于 GitHub 上，目前是静态网站，所以没办法留言，有建议可以通过邮箱 z12502793@163.com 联系博主。（博主非常期待！） 虽然这个小站还是很穷，但博主会一点一点地让这里富裕起来的(ᕑᗢᓫ∗)˒"},{"title":"friends","path":"/friends/index.html","content":"博主目前没有朋友 (っ◞‸◟c)"}]