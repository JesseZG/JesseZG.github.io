[{"title":"Python+scipy+matplotlib实现任意一元函数拟合","path":"/2023/11/29/Python+scipy+matplotlib实现任意一元函数拟合/","content":"前言之前在大学组织里面参加校内举办的智能汽车竞赛，顺便用 Python 研究了下一元函数拟合。虽然没用到，但闲着没事的时候用 Tkinter 封装好了程序。本文大致介绍一些程序设计的思路，因为文件太大不适合在 Github 上部署，所以在最后附上了源代码。因为博主是 Python 初学者，所以无论是算法方面还是逻辑方面可能都会有可以优化的地方，有建议可以通过邮箱 &#x7a;&#49;&#x32;&#x35;&#x30;&#x32;&#55;&#x39;&#x33;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#109; 反馈。 工具介绍Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，经常用于数据分析、人工智能等领域的程序设计，具有 Numpy, Scipy 等多种科学计算库，可以对数学运算进行简化。 Tkinter 是 Python 中的一个 GUI 库，能够通过 Windows 系统的 GUI 设计接口实现良好的本地窗口风格，缺点是难以封装成 .exe 程序。 scipy 实现函数拟合（待补充） matplotlib 查看拟合函数效果（待补充） tkinter 实现程序GUI界面（待补充） 代码没有用 Tkinter 打包的拟合原代码123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, b, c): return b*x + c# 输入要拟合的x,y的值的原始数据x = np.array([600,700, 800, 900,1000,1100,1200,1300,1400])y = np.array([800,900,1000,1100,1200,1200,1300,1400,1490])#进行函数拟合,abcd为输出函数参数，para为拟合效果参数abcd, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(abcd)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)# 后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况predict_past = 100predict_future = 100#将拟合的函数转换成函数图像微分形式X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000)Y = f(X, *abcd)#绘制拟合前数据点图效果和拟合后函数图像效果fig, ax = plt.subplots()ax.set_title(&quot;function fitting curve&quot;)ax.set_xlabel(&quot;right_speed&quot;)ax.set_ylabel(&quot;left_speed&quot;)ax.scatter(x, y)ax.plot(X, Y, color=&quot;r&quot;)plt.show() Tkinter 封装后的代码使用方法在 Python 环境下运行文件，在第一行中选择要拟合的变量数，第二行输入要拟合成的函数表达式（表达式为函数x侧的多项式，用 Python 数学表达式的方法表示，参数从 a 开始，数量要与要拟合的参数数保持对应；例如要拟合的函数为普通二次函数,应输入ax**2+bx+c）。 第三、四行输入要拟合的 x, y 变量的原始值，必须要一一对应，数量不能少于拟合参数数量，两个数字之间用逗号分隔。 第五行输入拟合效果图像中变量 x, y 多余的范围，例如如果要拟合二次函数输入的 x 的初始值为 1, 2, 3; 输入的 y 的初始值为 1, 4, 9; 如果需要查看图像x，y的范围均为1，则展示拟合曲线在 x&#x3D;[0,4] 范围的二次曲线。如果不需要则都应该写成0,不写程序会报错。 第六行点击后即可执行程序，在右边会出现拟合函数图像，下面会出现很多个参数，依次是 a, b, c… 的拟合参数。 如果程序报错提示找不到 Numpy, Scipy, Tkinter, Matplotlib 等第三方库则需要在终端中输入 pip install 【需要的模块名】 下载对应模块。 其他报错可能是输入的问题，检查是否严格按照此处所写的使用方法执行。如果未能发现问题可以向邮箱 &#x7a;&#x31;&#50;&#53;&#x30;&#50;&#x37;&#x39;&#51;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d; 进行反馈。博主只是一个爱好编程的大学生，如果发现其他 bug、优化方案也可以通过邮箱向博主提建议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186import tkinter as tkfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAggimport matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as opimport sys# 定义拟合函数，每种对应一种参数数量def f1(x, a): return eval(entry1.get())def f2(x, a, b): return eval(entry1.get())def f3(x, a, b, c): return eval(entry1.get())def f4(x, a, b, c, d): return eval(entry1.get())def f5(x, a, b, c, d, e): return eval(entry1.get())def f6(x, a, b, c, d, e, f): return eval(entry1.get())def f7(x, a, b, c, d, e, f, g): return eval(entry1.get())def f8(x, a, b, c, d, e, f, g, h): return eval(entry1.get())# 按下按钮后执行def start(): # 清除画布上所有东西 for widget in frame_canva.winfo_children(): widget.destroy() # 要拟合的x,y的值的原始数据 x = eval(&quot;np.array([&quot; + entry2.get() + &quot;])&quot;) y = eval(&quot;np.array([&quot; + entry3.get() + &quot;])&quot;) #对每一种参数数量进行函数拟合,abcd为输出函数参数，para为拟合效果参数 if radio_value.get() == 1: abcd, para = op.curve_fit(f1, x, y) if radio_value.get() == 2: abcd, para = op.curve_fit(f2, x, y) if radio_value.get() == 3: abcd, para = op.curve_fit(f3, x, y) if radio_value.get() == 4: abcd, para = op.curve_fit(f4, x, y) if radio_value.get() == 5: abcd, para = op.curve_fit(f5, x, y) if radio_value.get() == 6: abcd, para = op.curve_fit(f6, x, y) if radio_value.get() == 7: abcd, para = op.curve_fit(f7, x, y) if radio_value.get() == 8: abcd, para = op.curve_fit(f8, x, y) # 将abcd打印出来替换原来的text6 text6 = tk.Label(frame_value, text=abcd) text6.grid(row=9, column=0, columnspan=2) # 后面都是用来看拟合图像效果的 #这个两参数用于预测拟合图像在给的值之前和之后的发展情况 predict_past = eval(&quot;np.array(&quot; + entry4.get() + &quot;)&quot;) predict_future = eval(&quot;np.array(&quot; + entry5.get() + &quot;)&quot;) #将拟合的函数转换成函数图像微分形式 X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000) if radio_value.get() == 1: Y = f1(X, *abcd) if radio_value.get() == 2: Y = f2(X, *abcd) if radio_value.get() == 3: Y = f3(X, *abcd) if radio_value.get() == 4: Y = f4(X, *abcd) if radio_value.get() == 5: Y = f5(X, *abcd) if radio_value.get() == 6: Y = f6(X, *abcd) if radio_value.get() == 7: Y = f7(X, *abcd) if radio_value.get() == 8: Y = f8(X, *abcd) #绘制拟合前数据点图效果和拟合后函数图像效果# --------------------------------------------------------# 这段是画图像的，但不知道具体在干嘛，以后可以研究研究 fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例 f_plot =fig.add_subplot(111)#划分区域 canvas = FigureCanvasTkAgg(fig,frame_canva) canvas.get_tk_widget().pack()#放置位置 plt.scatter(x, y) plt.plot(X, Y, color=&quot;r&quot;)# -------------------------------------------------------# 创建窗口window = tk.Tk()window.title(&quot;Fitting_curve&quot;)#定义四个框架，其中radio和value框架在frame里面，canva与frame并列frame = tk.Frame(window, width=150, height=80, borderwidth=5)frame_radio = tk.Frame(frame, width=150, height=80, borderwidth=5)frame_value = tk.Frame(frame, width=150, height=300, borderwidth=5)frame_canva = tk.Frame(window, width=150, height=400, borderwidth=5)# 定义radio框架中的内容text0 = tk.Label(frame_radio, text=&quot;参量数：&quot;)radio_value = tk.IntVar()radio1 = tk.Radiobutton(frame_radio, text=1, value=1, variable=radio_value)radio2 = tk.Radiobutton(frame_radio, text=2, value=2, variable=radio_value)radio3 = tk.Radiobutton(frame_radio, text=3, value=3, variable=radio_value)radio4 = tk.Radiobutton(frame_radio, text=4, value=4, variable=radio_value)radio5 = tk.Radiobutton(frame_radio, text=5, value=5, variable=radio_value)radio6 = tk.Radiobutton(frame_radio, text=6, value=6, variable=radio_value)radio7 = tk.Radiobutton(frame_radio, text=7, value=7, variable=radio_value)radio8 = tk.Radiobutton(frame_radio, text=8, value=8, variable=radio_value)#定义value框架中的内容text1 = tk.Label(frame_value, text=&quot;输入要拟合成的函数表达式&quot;)entry1 = tk.Entry(frame_value, width= 50)text2 = tk.Label(frame_value, text=&quot;输入要拟合的x变量&quot;)entry2 = tk.Entry(frame_value, width= 50)text3 = tk.Label(frame_value, text=&quot;输入要拟合的y变量&quot;)entry3 = tk.Entry(frame_value, width= 50)text4 = tk.Label(frame_value, text=&quot;输入要预测的x变量范围&quot;)entry4 = tk.Entry(frame_value, width= 25)text5 = tk.Label(frame_value, text=&quot;输入要预测的y变量范围&quot;)entry5 = tk.Entry(frame_value, width= 25)text6 = tk.Label(frame_value, text=&quot;&quot;)button = tk.Button(frame_value, text=&quot;开始拟合&quot;, command=start, pady=3)# 将radio和value一依次放在frame的上面frame_radio.pack(side=&quot;top&quot;)frame_value.pack(side=&quot;top&quot;)# 将radio中的东西用grid放置text0.grid(row=0, column=0)radio1.grid(row=0, column=1)radio2.grid(row=0, column=2)radio3.grid(row=0, column=3)radio4.grid(row=0, column=4)radio5.grid(row=0, column=5)radio6.grid(row=0, column=6)radio7.grid(row=0, column=7)radio8.grid(row=0, column=8)# 将value中的东西用grid放置text1.grid(row=0, column=0, columnspan=2)entry1.grid(row=1, column=0, columnspan=2,)text2.grid(row=2, column=0, columnspan=2)entry2.grid(row=3, column=0, columnspan=2)text3.grid(row=4, column=0, columnspan=2)entry3.grid(row=5, column=0, columnspan=2)text4.grid(row=6, column=0)entry4.grid(row=7, column=0)text5.grid(row=6, column=1)entry5.grid(row=7, column=1)text6.grid(row=9, column=0, columnspan=2)button.grid(row=8, column=0, columnspan=2)# 将frame和canva两个框架依次放在左边frame.pack(side=&quot;left&quot;)frame_canva.pack(side=&quot;left&quot;)# 在刚打开文件时还没有图像，这一段用来在刚打开文件时放一个图像fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例f_plot =fig.add_subplot(111)#划分区域canvas = FigureCanvasTkAgg(fig,frame_canva)canvas.get_tk_widget().pack()#放置位置# 监测是否关掉窗口，关掉后结束程序window.protocol(&quot;WM_DELETE_WINDOW&quot;, lambda: sys.exit())# 主循环window.mainloop() 研究用：二元函数拟合这个程序是博主和 Chatgpt 搞了一整天才实现的，依旧是通过 Scipy.optimize 实现二次函数拟合。程序中很多地方博主依旧不明白是怎么实现的，但是因为勉强可以用所以也发到这篇文章中了。这个程序还在研发中所以可能有很多 Bug，如果发现可以修改的地方可以通过邮箱&#122;&#x31;&#50;&#x35;&#x30;&#50;&#x37;&#57;&#x33;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#111;&#109; 告诉博主。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, a, b, c, d, e): return a*x[0]**2 + b*x[0] + c*x[1]**2 + d*x[1] + e# 输入要拟合的x1, x2, y的值的原始数据, x1的格式与y横行长度相同，x2的格式与y竖行长度相同x1 = (1, 2, 3, 4, 5, 6)x2 = (1, 2, 3, 4, 5)y = np.array([[3, 10, 21, 36, 55, 78], [4, 11, 22, 37, 56, 79], [5, 12, 23, 38, 57, 80], [6, 13, 24, 39, 58, 81], [7, 14, 25, 40, 59, 82]])# x1, x2, y整理形式进行函数拟合x1, x2 = np.meshgrid(x1, x2)x = np.vstack((x1.flatten(), x2.flatten()))y = y.flatten()abc, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(*abc)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)#后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况x1_past = 3x1_future = 3x2_past = 3x2_future = 3# #将拟合的函数转换成函数图像微分形式X1 = np.linspace(x1[0, 0] - x1_past, x1[0, -1] + x1_future, 101) # 创建非周期性网格X2 = np.linspace(x2[0, 0] - x2_past, x2[-1, 0] + x2_future, 101) # 创建非周期性网格X = np.meshgrid(X1, X2)Y = (f(X, *abc))#绘制拟合前数据点图效果和拟合后函数图像效果ax = plt.subplot(projection=&quot;3d&quot;)ax.scatter(x[0], x[1], y, color=&quot;black&quot;)ax.plot_surface(X[0], X[1], Y, cmap=&quot;rainbow&quot;)ax.set_xlabel(&quot;x1&quot;)ax.set_ylabel(&quot;x2&quot;)ax.set_zlabel(&quot;y&quot;)plt.show()","tags":["数学","Python"],"categories":["程序设计"]},{"title":"Markdown 语言的语法和书写规范","path":"/2023/11/27/Markdown 语言的语法和书写规范/","content":"前言很早之前学 html 的时候就认识了 Markdown 语言，但当时对 Markdown 的理解就是 html 的简化版，所以学了也很快就忘记了。最近因为要写博客，所以顺便学习了 Markdown 的基本知识，对Markdown 文本有了更深的了解，所以写了这么一篇文章来回忆总结一下 Markdown 的基本语法和规范。 Markdown 语言的基本语法我认为 Markdown 就是一个更方便书写的，能够用 html 表示的一种简约的标记语言， Markdown 标记之后的文章具有比 html 更强大的可读性，而且也不需要像 Word 一样的排版和缩进，通过使用 Markdown 在不严重破坏 html 的同时增进代码中文本书写的速度。 Markdown 标题语法Markdown 的标题是通过井号 “#” 实现的，实现方法就是多少个标题就写多少个 “#” 。井号后面要加一个空格，然后写后面的内容比如三级标题就要输入“### [内容]”。 井号越少越高级，通常一个井号代表文章标题，两个个井号代表大节，三个井号代表大节下的小标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一、二级标题可以用等号 “&#x3D;” 和减号 “-” ，方法是在要输入的标题下面输入任意数量的等号或减号。 12345一级标题===二级标题--- 此外，在 Markdown 语言中，在一行中的连续三个星号“*”,破折号“-”，下划线“_”，可以实现分割线的作用。（可以在符号中间插入空格）。 123456789101112131415分割线***分割线---分割线___### Markdown 段落换行语法Markdown中没有专用的换行符，创建段落就需要在两段话之间加入一个空行。``` Markdown第一行段落第二行段落 在一行的末尾加两个空格后按回车，可以实现换行。 12第一行 第二行 Markdown 强调语法markdown 语言中使用星号 “*” 实现粗体和斜体。 要以斜体展示一段文字需要在文字两端加一对星号 “*” ，如 “*[内容]*”。 要加粗展示一段文字需要在文字两端加两对星号 “*” ，如 “**[内容]**”。 如果要对一段文字同时进行加粗和斜体展示，则需要在文字两端加三对星号“*”，如“***[内容]***”。 12345**粗体文字** *斜体文字****粗体斜体文字*** 粗体文字 斜体文字 粗体斜体文字 Markdown 引用语法Markdown 语言通过在文字前加上小于号 “&gt;” 可以实现对一段文字进行块引用。如果需要对多段文字进行引用，怎需要在每一段文字的开头都加上小于号 “&gt;” 。 1&gt; 即使跌倒一百次，也要一百零一次地站起来。 即使跌倒一百次，也要一百零一次地站起来。 Markdown 语言还可以通过多个大于号实现多层引用（如果高层引用直接接上底层引用可能会无法正常显示）。 12345678&gt;&gt; 外层引用&gt;&gt;&gt; 中层引用&gt;&gt;&gt;&gt; 里层引用&gt;&gt;&gt;&gt;&gt;&gt; 中层引用&gt;&gt;&gt;&gt; 外层引用 外层引用 中层引用 里层引用 中层引用 外层引用 Markdown 列表语法如果 Markdown 语言中可实现类似于 html 语言的有序列表和无序列表。有序列表需要在段落前加数字和点“.”来表示，如 “1. [内容]” 。 1234561. 第一点2. 第二点3. 第三点 1. 插入第一点 2. 插入第二点4. 第四点 第一点 第二点 第三点 插入第一点 插入第二点 第四点 无序列表可以通过在段落前添加加号 “+” ，减号 “-” ，星号 “*” 中的任意一个来表示无序列表。通过灵活使用三者可以实现列表嵌套。 123456- 第一点- 第二点- 第三点 * 插入 * 插入- 第四点 第一点 第二点 第三点 插入 插入 第四点 Markdown 代码语法在 Markdown 语言中，如果需要用段落表示代码，可以将其包裹在反引号 (&#96;) 中。如果代码中含有单引号，可以将代码包含于两对单引号中。 1` print(&quot;hello world!&quot;) ` print(&quot;hello world!&quot;) 代码块用三对反引号表示 123``` Pythonprint(&quot;hello world!&quot;)```# 1print(&quot;hello world!&quot;) 注：代码中不存在井号“#”，此处用于防止与前面 Markdown 前的三引号闭合。 Markdown 链接语法类似于 html 中的超链接，Markdown 的超链接语法格式为 [超链接显示内容](地址 “超链接鼠标悬浮显示的标题”) 。 1[Jesse](https://jessezg.github.io) Jesse Markdown 图片语法类似于 html 中的 img 标签，Markdown 的图片语法格式为 ![超链接显示内容](地址 “超链接鼠标悬浮显示的标题”) ，与链接语法不同的是中括号前面要加上感叹号 “!” 。 1&#123;% image https://jessezg.github.io/images/markdown.png,图片不存在！ %&#125; Markdown 转义字符语法由于一些字符在 Markdown 语言中有具体的作用，为了在段落中能够使用这些字符，需要对字符进行转义。下表展示了所有需要在字符前加上反斜杠 “\\” 来对文字进行转义的字符。 \\\t&#96;\t*\t_\t{ }\t[ ]\t( ) # + - . ! | 此外，由于 html 语言内部特性，，小于号“&lt;”和并号“&amp;”不能通过反斜杠 “\\”进行转义，必须要使用&amp;lt; 和 &amp;amp;对这两个字符进行转义(其他ASCII字符也可以通过这种方式进行转义)。 1\\\\\t\\`\t\\*\t\\_\t\\&#123; \\&#125;\t\\[ \\]\t\\( \\)\t\\# \\+ \\- \\. \\! \\| \\\t`\t*\t_\t{ }\t[ ]\t( )\t# + - . ! | 1&amp;amp; &amp;lt; &amp; &lt; Markdown 内嵌 HTML 标签由于 Markdown 语言是HTML语言的简单表示形式，如果需要使用一些 HTML 中存在而 Markdown 中没有收录的 HTML 标签，或者需要通过 HTML 语言在 Markdown 文档中实现复杂的效果，如表格&lt;table&gt;标签，需要嵌入相应的 HTML 标签，直接在需要使用标签的位置嵌入即可。 123456789101112131415161718192021&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;列标题1&lt;/th&gt; &lt;th&gt;列标题2&lt;/th&gt; &lt;th&gt;列标题3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;行1，列1&lt;/td&gt; &lt;td&gt;行1，列2&lt;/td&gt; &lt;td&gt;行1，列3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2，列1&lt;/td&gt; &lt;td&gt;行2，列2&lt;/td&gt; &lt;td&gt;行2，列3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 列标题1 列标题2 列标题3 行1，列1 行1，列2 行1，列3 行2，列1 行2，列2 行2，列3 如果需要在 Markdown 文档中使用注释，也可以使用 HTML 的注释格式&lt;!– –&gt;来表示。 123我不是注释&lt;!-- 我是注释 --&gt;我不是注释 我不是注释 我不是注释 Markdown 语言的书写规范(待补充) GFM 规范中文段落规范中文字符规范","tags":["Markdown","博客维护"],"categories":["程序设计"]},{"title":"网站建设日志 2023.11.27","path":"/2023/11/27/网站建设日志 2023.11.27/","content":"网站建设心路忙活了一个周末,终于把这个以hexo为基础的静态博客做完了。最开始我是想当成朋友圈用而想要建立的这个网站，现在因为我想要把我以后写的作品什么的放到博客上，总之就是一直有搭建博客的一个想法，本来我打算是用html和nodejs做一个简单的，但是还是需要太多相关知识了，研究了两天几乎没有什么收获，恐怕我到毕业之后也没有什么进展了。之前我一直认为搭建博客一定是要数据库、 API 等后端知识的，我只会一点点 Python 和 JavaScript ，所以要搭建网站这个事一直在推着。上周周末闲的没事看了点有关后端 API 的知识，意外看到了 Hexo 的视频，然后就跟着视频一点一点建完了。 感觉搭建网站其实挺简单的，尤其是可以部署到 GitHub 上，比我之前想的，要弄个服务器方便多了。而且基本上连前端的知识都没用到，学 Markdown 看着教程就可以直接做网站了，但网站之后的维护什么的还是有问题，总之先这么用着吧，等我把文章多写点能凑够个博客的量再说吧。 网站建设情况目前网站使用 Hexo 的 Stellar 框架，在 GitHub 上托管的。目前还没怎么搞明白 Hexo 框架的原理，但是已经能够糊弄着用了。目前网站样式选用 Stellar ，界面美观又清晰，这个是目前看来最合适的。现在没有头像，没有友链，文章也不够，这些问题之后都会一点一点解决的吧。 待解决 怎么排版这个问题说实话我也没什么经验，之前从没用过 Markdown 写文章，所以就算是能用 Markdown 写文章也不知道格式、叙述怎么解决，但我觉得这个问题大概多写一些就会有经验了吧，总之现在尽量保证文章的数量，文章质量的话可以以后再优化。 头像头像我打算找时间设计一个独特一点的，因为还没有真的动手去做，所以不知道做好是什么样的呢，总之先留着吧。 静态网站的数据这个问题是早晚要面对的，只不过现在看来不算很严重。首先是因为 GitHub 上好像只能写 1 GB 的文件，所以我要是一直这么加东西的话早晚会有网站过大的一天，其次 是 GitHub 上部署的文件没有数据库，所以没办法获得访问者的数量、情报、评论什么的，因此现在看来或许我可以把我的文章多在这上面存着，但这不是什么长久的计策。我大学毕业前要是一直能用的话就等到大学毕业再试着改成动态网站吧。虽然动态网站对我来说实在是太难搞了，但一点一点学总会有进步的。 访客因为静态网站没办法获得访客数量和评论，所以我或许可以写一个有关访客怎么反馈的文章。","tags":["博客维护"],"categories":["博客维护"]},{"title":"about","path":"/about/index.html","content":"欢迎来到 JesseZG 的小破站！博主是测控专业大二学生，爱好编程和游戏，在博客上记录一些生活学习经历如果对博主或博主的小站感兴趣欢迎通过邮箱&#x7a;&#49;&#x32;&#53;&#x30;&#x32;&#x37;&#57;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;交流(ᕑᗢᓫ∗)˒"}]