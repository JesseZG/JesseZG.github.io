[{"title":"hexo-renderer-markdown-it 语法","path":"/posts/278629411/","content":"前言 最近因为在研究博客，意外在 theme 的 config_yml 里面发现了 MathJax, Mermaid, KaTeX 这三个我不认识的东西，稍微连接一下才知道 Markdown 除了最基本的 HTML 功能以外还可以扩展，再深入一点研究发现了 GFM 扩展和规范，更新了我对 Markdown 语言的很多认知，因此我想写一篇文章，记录下 GFM 的扩展规范，但后来发现 GFM 只是 GitHub 上使用的解释器的规定格式，和我的这个博客没有什么关系，因此文章都写完了到测试的时候才发现有的用不了，研究了好久都没搞明白Q_Q。 今天因为研究博客，发现了博客的解释器引擎这个东西，才知道我的博客可以修改解释器，不同的解释器在细节上会有不同的效果。之前是照着 CSDN 上的教程学的，装的解释器式 pandoc，但我自己都不知道。今天因为学了这个东西，所以研究了一下解释器，我认为我现在所使用的这个是足够好用的，能够支持 MathJax（但效果不如 pandoc），也能够使用很多插件，所以就选用这个了，记录一下这个解释器的一些语法。 因为这个文章之前使用来写 GFM 的，所以把以前的很多东西都留下来了，在此之上改成的 hexo-renderer-markdown-it 语法。 介绍 有关 GFM GFM 介绍 GitHub Flavored Markdown（简称 GFM）是目前最流行的 Markdown 扩展语法，是 Github 推荐的一种基于 Markdown 的一种纯文本的书写格式。它提供了包括表格、任务列表、删除线、围栏代码、Emoji 等原 Markdown 没有的标记语法，并规范了 Markdown 语言的书写格式。 GFM 语法 GFM 表格语法 在 GFM 中，可以通过连字符和“-”，通道符号“|”两个符号围成表格，来代替原本 Markdown 语言中的表格标签。表格尺寸可以自定义，表头与表格体用对应的多个连词符分开。 GFM 任务列表项语法 GFM 中，可以通过类似于无序列表，在加号 “+” ，连词符 “-” 或星号 “*” 后面加上空格中括号[ ]或者 “x” 中括号[x]来实现任务列表项。填写列表项后对应的 Markdown 源代码也会发生改变。 GFM 自动链接语法 GFM 中，可以在文件中写域名或网站，会直接变成一个链接。 GFM 删除线语法 GFM 中任意两对双波浪线 “ ~~ ”,可以实现删除线的效果，即 HTML 中的 &lt;del&gt; 标签。,单词两端不能加空格 GFM 代码块 GFM 可以通过代码块实现代码高亮。 GFM Emoji表情 GFM 中，可以通过在两端写上冒号 “:” 来表示 Emoji 表情。 hexo-renderer-markdown-it 介绍 hexo-renderer-markdown-it 式一个 hexo 的 Markdown 解释器，因为 Markdown 解释器众多，仅仅是在细节上有差别，所以正常使用的话用哪个都差不多，但如果需要进行数学表达式等就需要考虑解释器的问题了。博主目前最推荐 hexo-renderer-markdown-it（以下简称为 MI，这个名字博主自己起的不被广泛认可，仅用来简化表示），支持 MathJax（适配不是很好，需要调整），可以使用类似于 GFM 的所有功能，还有一些 MI 独有的功能，下面对 MI 的附增 Markdown 语法做一个研究和介绍。 MI 语法 MI 表格语法 在 MI 中，可以通过连字符和“-”，通道符号“|”两个符号围成表格，来代替原本 Markdown 语言中的表格标签（GFM 语法也可以实现）。表格尺寸可以自定义，表头与表格体用对应的多个连词符分开。 1234| 列标题一 | 列标题二 | 列标题三 | | --- | --- | --- || 行1，列1 | 行1，列2 | 行1，列3 | | 行2，列1 | 行2，列2 | 行2，列3 | 列标题一 列标题二 列标题三 行1，列1 行1，列2 行1，列3 行2，列1 行2，列2 行2，列3 MI 删除线语法 MI 中任意两对双波浪线 “ ~~ ”,可以实现删除线的效果，即 HTML 中的 &lt;del&gt; 标签（GFM 中也可以实现）。 1~~del~~ del 注：单词两端不能加空格 MI Emoji表情语法 MI 中，可以通过在两端写上冒号 “:” 来表示 Emoji 表情（在 GFM 中也可以实现）。 1234:grinning::heart_eyes::speech_balloon::peach: 😀 😍 💬 🍑 这些表情有很多，和 HTML 标签混合可以实现很多有趣的效果。可以在github官方表情中查找对应表情的编码。 MI 任务列表项语法 MI 中，可以通过类似于无序列表，在加号 “+” ，连词符 “-” 或星号 “*” 后面加上空格中括号[ ]或者 “x” 中括号[x]来实现任务列表项。填写列表项后对应的 Markdown 源代码也会发生改变。（GFM 也可以实现） 1234- [ ] 待办事项1- [ ] 待办事项2- [x] 待办事项3- [ ] 待办事项4 待办事项1 待办事项2 待办事项3 待办事项4 MI 上下标语法 MI 通过在内容两边加上“^”表示上标，加上“~”表示下标（无法共同表示）。 1x^2^~1~+x^2^~2~ = 1 x21 + x22 = 1 MI 标记下划线语法 MI 通过在内容两边加上两个等号“==”表示标记，加两个加号“++”表示下划线。 12==标记==++下划线++ 标记下划线 自动链接语法 MI 中，可以在文件中写域名或网站，会直接变成一个链接。 www.bing.com z12502793@163.com MI 折叠 在一段文字前后加上三个加号“+++”可以实现折叠功能,折叠前的文字用前后各两个星号“*”包围。 123+++ **展开**隐藏内容+++ &nbsp;展开隐藏内容 自定义容器 可以实现自定义容器（大概大概为设置 div 盒子中的 id），在 hexo 或其他网站的 css 中添加即可自定义容器，使用的方法为在段落前后加上三个冒号，第一段空格加上 容器的 id 名即可实现自定义容器，下面是四个例子。 12345678910111213141516171819::: tips**提示**这是一个提示:::::: warning**注意**这是一个警告:::::: danger**警告**这是一个危险信号:::::: success**成功**这是一个成功信号::: 提示 这是一个提示 注意 这是一个警告 警告 这是一个危险信号 成功 这是一个成功信号","tags":["Markdown"],"categories":["技术小屋","Markdown"]},{"title":"MathJax 语法","path":"/posts/516810661/","content":"前言 因为想要深入了解 Hexo，在翻文档的时候找到 MathJax，KaTeX，Mermaid 这三个东西，今天无聊所以顺便研究了一下，感觉还算是有用，所以写了这一篇文章整理一下这 MathJax 的功能和语法。 语言介绍 MathJax MathJax 是一个用于 Latex、Mathml 和 Ascimath 表示法的开源 JavaScript 显示引擎，可在所有现代浏览器中工作，能够嵌入到 HTML 文件或 Markdown 文件中，通过 ASCII 字符书写一些常用的数学符号和公式。 KaTeX LaTeX 是 TeX 中的一种格式(format) ，是建立在 TeX 基础上的宏语言，能够通过文本实现图标表格、数学表达式、化学分子式，甚至五线谱、棋谱、电路图等通过文本难以实现的效果，是学生写论文的常用语言。 KaTeX 是 LaTeX 的一个子集，能够实现 LaTeX 中的数学公式部分，是一个支持 HTML 的轻量级的数学公式引擎。（ KaTeX 这个词实在是太难打啦！） MathJax 与 KaTeX MathJax 与 KaTeX 都是书写数学表达式的语言，语法相似，KaTeX 渲染更快，支持若干简写字符，但是本身支持的范围较小；MathJax 渲染稍慢，支持更多复杂的表示，本博客的数学公式（暂时）全部使用 MathJax，未来可能会更新有关 KaTeX 语法的内容。 MathJax 基础 MathJax 单行公式 Mathjax 默认情况可以使用单对、两对美元符号来表示。 12$ F = ma $$$ F = ma $$ $ F = ma $ $$ F = ma $$ 括号 小括号“ () ”和中括号“ [] ”在 MathJax 中可以直接表示；大括号“ { } ”通过“ \\{ ”，“ \\} ”表示，尖括号“”通过“ \\langle ”，“ \\rangle ”表示。 12$$ (), [], &#123;&#125; &lt;&gt;$$$$ \\&#123;, \\&#125;, \\langle, \\rangle $$ $$ (), [], {} &lt;&gt;$$ $$ {, }, \\langle, \\rangle $$ 上取整$\\text(\\lceil\\rceil)$通过使用\\lceil和\\rceil表示，下取整$\\text(\\lceil\\rceil)$通过使用\\lceil和\\rceil表示。 123$$ \\lceil &#123;2.8&#125; \\rceil = 3 $$$$ \\lfloor &#123;2.8&#125; \\rfloor = 2 $$ $$ \\lceil {2.8} \\rceil = 3 $$ $$ \\lfloor {2.8} \\rfloor = 2 $$ 上下标 当数学表达式中需要表示上标、下标、次方时依次通过上箭头“^”和下划线“_”后面加上数字表示。 123$$ x ^ 2 $$$$ x _ 1 $$$$ x ^ 2 _ 1 + x ^ 2 _ 2 = 1 $$ $$ x ^ 2 $$ $$ x _ 1 $$ $$ x ^ 2 _ 1 + x ^ 2 _ 2 = 1 $$ 分组 当表达式多于一个字符时，需要用大括号“ { } ”括起来。 1$$ a ^ x = e ^ &#123;xlna&#125; $$ $$ a ^ x = e ^ {xlna} $$ 如果希望表达式中没有字符，也可以通过大括号中不加内容代表空字符。 12$$ x ^ &#123;&#125; $$ $$ x ^ {} $$ 分式根式 MathJax中分式有两种表示形式。 “\\frac”，后面接的两个表达式依次是分子和分母。 1$$ \\frac 1 &#123;x^2+1&#125; $$ $$ \\frac 1 {x^2+1} $$ “\\over”，前面是表达式的分子，右面是表达式的分母。 1$$ 1 \\over &#123;x^2+1&#125; $$ $$ 1 \\over {x^2+1} $$ 3.“\\frac”会使表达的分子分母越来越小，不建议表示繁分数，连分数等，可以使用“\\cfrac”进行表示。 求和积分极限符号 在 MathJax 中，无穷写作\\infty。 1$$ \\infty $$ $$ \\infty $$ 求和、求积、积分、二重积分、三重积分、环积分其实就是一个符号，通过加上下标实现，分别写作“ \\sum ”“ \\prod ”“ \\int ”“ \\iint ”“ \\iiint ”“ \\oint ” 如果需要将数字写到这些符号的正下、上方，需要在转移式后接上\\limits_来将上下标写在正上、下方。 12345$$ \\sum \\limits _ &#123;k=1&#125; ^ n = \\frac 1 2 n(n+1) $$$$ \\int x ^ \\alpha dx = \\frac &#123;x^&#123;a+1&#125;&#125; &#123;ax+1&#125; + c $$$$ \\prod _ &#123;p\\epsilon A&#125; \\frac &#123;p^2&#125; &#123;p^2-1&#125; = \\frac &#123;\\pi^2&#125; 6 $$$$ \\iint _ D f(x,y) dxdy = \\int ^ &#123;2\\pi&#125; _ 0 \\int ^ &#123;\\rho&#125; _ 0 f(\\rho,\\theta) \\rho d\\rho d\\theta $$$$ \\oint f(z) dz = 0 $$ $$ \\sum \\limits _ {k=1} ^ n = \\frac 1 2 n(n+1) $$ $$ \\int x ^ \\alpha dx = \\frac {x^{a+1}} {ax+1} + c $$ $$ \\prod _ {p\\epsilon A} \\frac {p^2} {p^2-1} = \\frac {\\pi^2} 6 $$ $$ \\iint _ D f(x,y) dxdy = \\int ^ {2\\pi} _ 0 \\int ^ {\\rho} _ 0 f(\\rho,\\theta) \\rho d\\rho d\\theta $$ $$ \\oint f(z) dz = 0 $$ 极限同理，用\\to 表示趋近于。 1$$ \\lim \\limits _ &#123;x\\to0&#125; \\frac &#123;sinx&#125; x = 1 $$ $$ \\lim \\limits _ {x\\to0} \\frac {sinx} x = 1 $$ 空间分布 MathJax 中无法通过空格分隔字符，可以通过在两个字符中间间加入“\\quad”和“\\qquad”会增加间隔。 12345$$ ab $$$$ a b $$$$ a b $$$$ a \\quad b $$$$ a \\qquad b $$ $$ ab $$ $$ a b $$ $$ a b $$ $$ a \\quad b $$ $$ a \\qquad b $$ 在 MathJax 中由于空格不会影响排版，可以通过空格提高语句可读性，解决单词连起来的问题。 顶部符号 在变量前面加上“\\hat”上的“倒帽子”；如果对多个变量表示倒帽子需要在前面加上“\\widehat”表示“长倒帽子”，类似的还有 ： “\\overline”（平均值的横帽子） \\vec（向量的箭头帽子） \\overrightarrow（向右的箭头帽子） \\overrightarrow（向右的箭头帽子） \\dot（变量上面一个点） \\ddot（变量上面两个点）。 1$$ \\hat x,\\hat &#123;xy&#125;,\\widehat x,\\widehat &#123;xy&#125;,\\overline x,\\vec x,\\overrightarrow x,\\overleftarrow x,\\dot x,\\ddot x $$ $$ \\hat x,\\hat {xy},\\widehat x,\\widehat {xy},\\overline x,\\vec x,\\overrightarrow x,\\overleftarrow x,\\dot x,\\ddot x $$ 希腊及其他字母 MathJax 中小写希腊字母由斜杠加上希腊字母的英文名来表示，大写希腊字母需要将英文名首字母大写（如果一个希腊大写字母在拉丁大写字母中也存在,可以直接用大写拉丁字母表示）。 1234567$$ \\Gamma, \\Delta, \\Theta, \\Lambda, \\Xi, \\Pi, \\Sigma, \\Upsilon, \\Phi, \\Psi, \\Omega $$$$ \\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\zeta, \\eta, \\theta, \\iota, \\kappa, \\lambda, \\mu, u, \\xi, \\omicron, \\pi, \\rho, \\sigma, \\tau, \\upsilon, \\phi, \\chi, \\psi, \\omega $$ $$ \\Gamma, \\Delta, \\Theta, \\Lambda, \\Xi, \\Pi, \\Sigma, \\Upsilon, \\Phi, \\Psi, \\Omega $$ $$ \\alpha, \\beta, \\gamma, \\delta, \\epsilon, \\zeta, \\eta, \\theta, \\iota, \\kappa, \\lambda, \\mu, u, \\xi, \\omicron, \\pi, \\rho, \\sigma, \\tau, \\upsilon, \\phi, \\chi, \\psi, \\omega $$ 对于一些其他有多种表示方法的希腊字母和希伯来字母在此列出。 123$$ \\digamma, \\varepsilon, \\vartheta, \\varkappa, \\varpi, \\varrho, \\varsigma, \\varphi, \\aleph, \\beth, \\daleth, \\gimel $$ $$ \\digamma, \\varepsilon, \\vartheta, \\varkappa, \\varpi, \\varrho, \\varsigma, \\varphi , \\aleph, \\beth, \\daleth, \\gimel $$ 字体 为适应不同的学科需求（主要是数学） MathJax 可以表示多种字体。 使用“\\mathbb”和“\\Bbb”来表示黑板粗体字，常用于表示数集（没有小写的形式）。 12$$ \\mathbb &#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $$$$ \\Bbb &#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $$ $$ \\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ} $$ $$ \\Bbb {ABCDEFGHIJKLMNOPQRSTUVWXYZ} $$ 使用“\\mathbf”表示黑体字。 12$$ \\mathbf &#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $$$$ \\mathbf &#123;abcdefghijklmnopqrstuvwxyz&#125; $$ $$ \\mathbf {ABCDEFGHIJKLMNOPQRSTUVWXYZ} $$ $$ \\mathbf {abcdefghijklmnopqrstuvwxyz} $$ 使用“\\mathtt”表示打印机字体。 12$$ \\mathtt &#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $$$$ \\mathtt &#123;abcdefghijklmnopqrstuvwxyz&#125; $$ $$ \\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZ} $$ $$ \\mathtt {abcdefghijklmnopqrstuvwxyz} $$ 使用“\\mathrm”表示打印机字体。 12$$ \\mathrm &#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $$$$ \\mathrm &#123;abcdefghijklmnopqrstuvwxyz&#125; $$ $$ \\mathrm {ABCDEFGHIJKLMNOPQRSTUVWXYZ} $$ $$ \\mathrm {abcdefghijklmnopqrstuvwxyz} $$ 使用“\\mathscr”表示手写花体。（没有小写的形式） 1$$ \\mathscr &#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $$ $$ \\mathscr {ABCDEFGHIJKLMNOPQRSTUVWXYZ} $$ 使用“\\mathfrak”表示Fraktur字体（我也不知道是什么(⌯꒪꒫꒪)੭）。 1$$ \\mathfrak &#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $$ $$ \\mathfrak {ABCDEFGHIJKLMNOPQRSTUVWXYZ} $$ $$ \\mathfrak {abcdefghijklmnopqrstuvwxyz} $$ 颜色 在 MathJax 中，通过“\\color”来对文本实现染色，之后接的第一个变量是想要显示的文字颜色（直接写颜色名），第二个变量是要染色的文本。 1$$ \\color &#123;red&#125; &#123;\\text &#123;I&#x27;m red&#125;| $$ $$ \\color {red} {\\text {I’m red}| $$ 注：命名颜色是浏览器相关的，如果浏览器没有定义相关的颜色名称，则相关文本将被渲染为黑色，推荐使用十六进制的二进制保护色。 其他符号 三角函数 常见的三角函数可以直接在前面加上斜杠表示。 1$$ \\csc x, \\arcsin x, \\tanh x $$ $$ \\csc x, \\arcsin x, \\tanh x $$ 比较运算符 1$$ \\lt, \\gt, \\le, \\ge, eq $$ $$ \\lt, \\gt, \\le, \\ge, eq $$ 可以在这些运算符前面加上“ ot”来表示“不”的意思。 1$$ ot \\lt, ot \\gt, ot \\le, ot \\ge, ot eq $$ $$ ot \\lt, ot \\gt, ot \\le, ot \\ge, ot eq $$ 运算符号 1$$ \\times, \\div, \\pm, \\mp $$ $$ \\times, \\div, \\pm, \\mp $$ 省略号 1$$ \\cdots, \\ldots, \\dots, \\ddots, \\vdots $$ $$ \\cdots, \\ldots, \\dots, \\ddots, \\vdots $$ \\ldots比\\cdots高一些 集合运算符 123$$ \\cup, \\cap, \\setminus, \\subset, \\subseteq, \\subsetneq, \\supset, \\in, otin, \\emptyset, \\varnothing $$ $$ \\cup, \\cap, \\setminus, \\subset, \\subseteq, \\subsetneq, \\supset, \\in, otin, \\emptyset, \\varnothing $$ 表示排列数 集合有两种表示方式 12$$ \\binom &#123;n+1&#125; &#123;2k&#125; $$$$ &#123;n+1 \\choose 2k&#125; $$ $$ \\binom {n+1} {2k} $$ $$ {n+1 \\choose 2k} $$ 箭头 1$$ \\to, \\rightarrow, \\leftarrow, \\Rightarrow, \\Leftarrow, \\mapsto $$ $$ \\to, \\rightarrow, \\leftarrow, \\Rightarrow, \\Leftarrow, \\mapsto $$ 逻辑运算符 1$$ \\land, \\lor, \\lnot, \\forall, \\exists, \\top, \\bot, \\vdash, \\vDash $$ $$ \\land, \\lor, \\lnot, \\forall, \\exists, \\top, \\bot, \\vdash, \\vDash $$ 表示等于含义的符号 1$$ \\approx, \\sim, \\cong, \\equiv, \\prec $$ $$ \\approx, \\sim, \\cong, \\equiv, \\prec $$ 取余符号 1$$ a \\equiv b \\pmod n $$ $$ a \\equiv b \\pmod n $$ 其他符号 1$$ \\star, \\ast, \\oplus, \\circ, \\bullet $$ $$ \\star, \\ast, \\oplus, \\circ, \\bullet $$ 1$$ \\infty, \\aleph_o, abla, \\partial, \\Im, \\Re $$ $$ \\infty, \\aleph_o, abla, \\partial, \\Im, \\Re $$ 其他示例 1$$ \\&#123; x \\mid x\\in \\Bbb Z\\&#125; $$ $$ { x \\mid x \\in \\Bbb Z} $$ MathJax 多行公式 （待补充） MathJax 标记和引用","tags":["数学","Markdown"],"categories":["技术小屋","Markdown"]},{"title":"Python + Scipy + Matplotlib 实现任意一元函数拟合","path":"/posts/3950149617/","content":"前言 之前在大学组织里面参加校内举办的智能汽车竞赛，顺便用 Python 研究了下一元函数拟合。虽然没用到，但闲着没事的时候用 Tkinter 封装好了程序。本文大致介绍一些程序设计的思路，因为文件太大不适合在 Github 上部署，所以在最后附上了源代码。因为博主是 Python 初学者，所以无论是算法方面还是逻辑方面可能都会有可以优化的地方，有建议可以通过邮箱 z12502793@163.com 反馈。 工具介绍 Python Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，具有良好的可移植性和可扩展性，最初被设计用于编写自动化脚本(shell)。随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发，在科学计算、人工智能、Web开发、网络爬虫、数据分析等领域都有广泛的应用。 Numpy 和 Scipy Numpy 和 Scipy 是Python的两个科学计算库。Numpy 提供了数组对象，以及许多用于操作这些数组的函数；Scipy 是一个用于科学计算的 Python 库，它包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。Numpy 和 Scipy 的协同工作可以高效解决很多问题，在人工智能、数据分析等众多领域中得到了广泛应用。 Matplotlib 和 Pyplot Matplotlib 是 Python 的一个绘图库，它能提供多样化的输出格式实现数据可视化。Pyplot 是 Matplotlib 的子库，提供了和 MATLAB 类似的绘图API，是 Python 常用的绘图模块，能很方便绘制函数图像或统计图。 Tkinter Tkinter 提供了多种控件，如按钮，标签，文本框等，以及标准属性和方法，如大小，颜色，字体等，是Python的标准Tk GUI工具包的接口。 Scipy 实现函数拟合 （待完成） 定义函数 原始数据 scipy.optimise 实现函数拟合效果 Matplotlib 查看拟合函数效果 预测函数常数 通过 numpy.linspace 实现拟合函数微分效果 绘制图像 Tkinter 实现程序GUI界面 Tkinter 布局 Matplotlib 嵌入 通过 eval 函数实现字符串转化 通过 sys 库结束程序 代码 没有用 Tkinter 打包的拟合原代码 123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, b, c): return b*x + c# 输入要拟合的x,y的值的原始数据x = np.array([600,700, 800, 900,1000,1100,1200,1300,1400])y = np.array([800,900,1000,1100,1200,1200,1300,1400,1490])#进行函数拟合,abcd为输出函数参数，para为拟合效果参数abcd, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(abcd)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)# 后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况predict_past = 100predict_future = 100#将拟合的函数转换成函数图像微分形式X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000)Y = f(X, *abcd)#绘制拟合前数据点图效果和拟合后函数图像效果fig, ax = plt.subplots()ax.set_title(&quot;function fitting curve&quot;)ax.set_xlabel(&quot;right_speed&quot;)ax.set_ylabel(&quot;left_speed&quot;)ax.scatter(x, y)ax.plot(X, Y, color=&quot;r&quot;)plt.show() Tkinter 封装后的代码 使用方法 在 Python 环境下运行文件，在第一行中选择要拟合的变量数，第二行输入要拟合成的函数表达式（表达式为函数x侧的多项式，用 Python 数学表达式的方法表示，参数从 a 开始，数量要与要拟合的参数数保持对应；例如要拟合的函数为普通二次函数,应输入ax**2+bx+c）。 第三、四行输入要拟合的 x, y 变量的原始值，必须要一一对应，数量不能少于拟合参数数量，两个数字之间用逗号分隔。 第五行输入拟合效果图像中变量 x, y 多余的范围，例如如果要拟合二次函数输入的 x 的初始值为 1, 2, 3; 输入的 y 的初始值为 1, 4, 9; 如果需要查看图像x，y的范围均为1，则展示拟合曲线在 x=[0,4] 范围的二次曲线。如果不需要则都应该写成0,不写程序会报错。 第六行点击后即可执行程序，在右边会出现拟合函数图像，下面会出现很多个参数，依次是 a, b, c… 的拟合参数。 如果程序报错提示找不到 Numpy, Scipy, Tkinter, Matplotlib 等第三方库则需要在终端中输入 pip install 【需要的模块名】 下载对应模块。 其他报错可能是输入的问题，检查是否严格按照此处所写的使用方法执行。如果未能发现问题可以向邮箱 z12502793@163.com 进行反馈。博主只是一个爱好编程的大学生，如果发现其他 bug、优化方案也可以通过邮箱向博主提建议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186import tkinter as tkfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAggimport matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as opimport sys# 定义拟合函数，每种对应一种参数数量def f1(x, a): return eval(entry1.get())def f2(x, a, b): return eval(entry1.get())def f3(x, a, b, c): return eval(entry1.get())def f4(x, a, b, c, d): return eval(entry1.get())def f5(x, a, b, c, d, e): return eval(entry1.get())def f6(x, a, b, c, d, e, f): return eval(entry1.get())def f7(x, a, b, c, d, e, f, g): return eval(entry1.get())def f8(x, a, b, c, d, e, f, g, h): return eval(entry1.get())# 按下按钮后执行def start(): # 清除画布上所有东西 for widget in frame_canva.winfo_children(): widget.destroy() # 要拟合的x,y的值的原始数据 x = eval(&quot;np.array([&quot; + entry2.get() + &quot;])&quot;) y = eval(&quot;np.array([&quot; + entry3.get() + &quot;])&quot;) #对每一种参数数量进行函数拟合,abcd为输出函数参数，para为拟合效果参数 if radio_value.get() == 1: abcd, para = op.curve_fit(f1, x, y) if radio_value.get() == 2: abcd, para = op.curve_fit(f2, x, y) if radio_value.get() == 3: abcd, para = op.curve_fit(f3, x, y) if radio_value.get() == 4: abcd, para = op.curve_fit(f4, x, y) if radio_value.get() == 5: abcd, para = op.curve_fit(f5, x, y) if radio_value.get() == 6: abcd, para = op.curve_fit(f6, x, y) if radio_value.get() == 7: abcd, para = op.curve_fit(f7, x, y) if radio_value.get() == 8: abcd, para = op.curve_fit(f8, x, y) # 将abcd打印出来替换原来的text6 text6 = tk.Label(frame_value, text=abcd) text6.grid(row=9, column=0, columnspan=2) # 后面都是用来看拟合图像效果的 #这个两参数用于预测拟合图像在给的值之前和之后的发展情况 predict_past = eval(&quot;np.array(&quot; + entry4.get() + &quot;)&quot;) predict_future = eval(&quot;np.array(&quot; + entry5.get() + &quot;)&quot;) #将拟合的函数转换成函数图像微分形式 X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000) if radio_value.get() == 1: Y = f1(X, *abcd) if radio_value.get() == 2: Y = f2(X, *abcd) if radio_value.get() == 3: Y = f3(X, *abcd) if radio_value.get() == 4: Y = f4(X, *abcd) if radio_value.get() == 5: Y = f5(X, *abcd) if radio_value.get() == 6: Y = f6(X, *abcd) if radio_value.get() == 7: Y = f7(X, *abcd) if radio_value.get() == 8: Y = f8(X, *abcd) #绘制拟合前数据点图效果和拟合后函数图像效果# --------------------------------------------------------# 这段是画图像的，但不知道具体在干嘛，以后可以研究研究 fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例 f_plot =fig.add_subplot(111)#划分区域 canvas = FigureCanvasTkAgg(fig,frame_canva) canvas.get_tk_widget().pack()#放置位置 plt.scatter(x, y) plt.plot(X, Y, color=&quot;r&quot;)# -------------------------------------------------------# 创建窗口window = tk.Tk()window.title(&quot;Fitting_curve&quot;)#定义四个框架，其中radio和value框架在frame里面，canva与frame并列frame = tk.Frame(window, width=150, height=80, borderwidth=5)frame_radio = tk.Frame(frame, width=150, height=80, borderwidth=5)frame_value = tk.Frame(frame, width=150, height=300, borderwidth=5)frame_canva = tk.Frame(window, width=150, height=400, borderwidth=5)# 定义radio框架中的内容text0 = tk.Label(frame_radio, text=&quot;参量数：&quot;)radio_value = tk.IntVar()radio1 = tk.Radiobutton(frame_radio, text=1, value=1, variable=radio_value)radio2 = tk.Radiobutton(frame_radio, text=2, value=2, variable=radio_value)radio3 = tk.Radiobutton(frame_radio, text=3, value=3, variable=radio_value)radio4 = tk.Radiobutton(frame_radio, text=4, value=4, variable=radio_value)radio5 = tk.Radiobutton(frame_radio, text=5, value=5, variable=radio_value)radio6 = tk.Radiobutton(frame_radio, text=6, value=6, variable=radio_value)radio7 = tk.Radiobutton(frame_radio, text=7, value=7, variable=radio_value)radio8 = tk.Radiobutton(frame_radio, text=8, value=8, variable=radio_value)#定义value框架中的内容text1 = tk.Label(frame_value, text=&quot;输入要拟合成的函数表达式&quot;)entry1 = tk.Entry(frame_value, width= 50)text2 = tk.Label(frame_value, text=&quot;输入要拟合的x变量&quot;)entry2 = tk.Entry(frame_value, width= 50)text3 = tk.Label(frame_value, text=&quot;输入要拟合的y变量&quot;)entry3 = tk.Entry(frame_value, width= 50)text4 = tk.Label(frame_value, text=&quot;输入要预测的x变量范围&quot;)entry4 = tk.Entry(frame_value, width= 25)text5 = tk.Label(frame_value, text=&quot;输入要预测的y变量范围&quot;)entry5 = tk.Entry(frame_value, width= 25)text6 = tk.Label(frame_value, text=&quot;&quot;)button = tk.Button(frame_value, text=&quot;开始拟合&quot;, command=start, pady=3)# 将radio和value一依次放在frame的上面frame_radio.pack(side=&quot;top&quot;)frame_value.pack(side=&quot;top&quot;)# 将radio中的东西用grid放置text0.grid(row=0, column=0)radio1.grid(row=0, column=1)radio2.grid(row=0, column=2)radio3.grid(row=0, column=3)radio4.grid(row=0, column=4)radio5.grid(row=0, column=5)radio6.grid(row=0, column=6)radio7.grid(row=0, column=7)radio8.grid(row=0, column=8)# 将value中的东西用grid放置text1.grid(row=0, column=0, columnspan=2)entry1.grid(row=1, column=0, columnspan=2,)text2.grid(row=2, column=0, columnspan=2)entry2.grid(row=3, column=0, columnspan=2)text3.grid(row=4, column=0, columnspan=2)entry3.grid(row=5, column=0, columnspan=2)text4.grid(row=6, column=0)entry4.grid(row=7, column=0)text5.grid(row=6, column=1)entry5.grid(row=7, column=1)text6.grid(row=9, column=0, columnspan=2)button.grid(row=8, column=0, columnspan=2)# 将frame和canva两个框架依次放在左边frame.pack(side=&quot;left&quot;)frame_canva.pack(side=&quot;left&quot;)# 在刚打开文件时还没有图像，这一段用来在刚打开文件时放一个图像fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例f_plot =fig.add_subplot(111)#划分区域canvas = FigureCanvasTkAgg(fig,frame_canva)canvas.get_tk_widget().pack()#放置位置# 监测是否关掉窗口，关掉后结束程序window.protocol(&quot;WM_DELETE_WINDOW&quot;, lambda: sys.exit())# 主循环window.mainloop() 研究用：二元函数拟合 这个程序是博主和 Chatgpt 搞了一整天才实现的，依旧是通过 Scipy.optimize 实现二次函数拟合。程序中很多地方博主依旧不明白是怎么实现的，但是因为勉强可以用所以也发到这篇文章中了。这个程序还在研发中所以可能有很多 Bug，如果发现可以修改的地方可以通过邮箱z12502793@163.com 告诉博主。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, a, b, c, d, e): return a*x[0]**2 + b*x[0] + c*x[1]**2 + d*x[1] + e# 输入要拟合的x1, x2, y的值的原始数据, x1的格式与y横行长度相同，x2的格式与y竖行长度相同x1 = (1, 2, 3, 4, 5, 6)x2 = (1, 2, 3, 4, 5)y = np.array([[3, 10, 21, 36, 55, 78], [4, 11, 22, 37, 56, 79], [5, 12, 23, 38, 57, 80], [6, 13, 24, 39, 58, 81], [7, 14, 25, 40, 59, 82]])# x1, x2, y整理形式进行函数拟合x1, x2 = np.meshgrid(x1, x2)x = np.vstack((x1.flatten(), x2.flatten()))y = y.flatten()abc, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(*abc)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)#后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况x1_past = 3x1_future = 3x2_past = 3x2_future = 3# #将拟合的函数转换成函数图像微分形式X1 = np.linspace(x1[0, 0] - x1_past, x1[0, -1] + x1_future, 101) # 创建非周期性网格X2 = np.linspace(x2[0, 0] - x2_past, x2[-1, 0] + x2_future, 101) # 创建非周期性网格X = np.meshgrid(X1, X2)Y = (f(X, *abc))#绘制拟合前数据点图效果和拟合后函数图像效果ax = plt.subplot(projection=&quot;3d&quot;)ax.scatter(x[0], x[1], y, color=&quot;black&quot;)ax.plot_surface(X[0], X[1], Y, cmap=&quot;rainbow&quot;)ax.set_xlabel(&quot;x1&quot;)ax.set_ylabel(&quot;x2&quot;)ax.set_zlabel(&quot;y&quot;)plt.show()","tags":["数学","Python"],"categories":["技术小屋","Python"]},{"title":"Markdown 语言基础语法","path":"/posts/913170794/","content":"前言 很早之前学 html 的时候就认识了 Markdown 语言，但当时对 Markdown 的理解就是 html 的简化版，所以学了也很快就忘记了。最近因为要写博客，所以顺便学习了 Markdown 的基本知识，对Markdown 文本有了更深的了解，所以写了这么一篇文章来回忆总结一下 Markdown 的基本语法和规范。 Markdown 语言介绍 Markdown是一种标记语言，排版语法非常简洁，使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。 Markdown 语言的基本语法 我认为 Markdown 就是一个更方便书写的，能够用 html 表示的一种简约的标记语言， Markdown 标记之后的文章具有比 html 更强大的可读性，而且也不需要像 Word 一样的排版和缩进，通过使用 Markdown 在不严重破坏 html 的同时增进代码中文本书写的速度。 Markdown 标题语法 Markdown 的标题是通过井号 “#” 实现的，实现方法就是多少个标题就写多少个 “#” 。井号后面要加一个空格，然后写后面的内容比如三级标题就要输入“### [内容]”。 井号越少越高级，通常一个井号代表文章标题，两个个井号代表大节，三个井号代表大节下的小标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一、二级标题可以用等号 “=” 和减号 “-” ，方法是在要输入的标题下面输入任意数量的等号或减号。 12345一级标题===二级标题--- 此外，在 Markdown 语言中，在一行中的连续三个星号“*”,破折号“-”，下划线“_”，可以实现分割线的作用。（可以在符号中间插入空格）。 123456***---___ Markdown 段落换行语法 Markdown中没有专用的换行符，创建段落就需要在两段话之间加入一个空行。 123第一行段落第二行段落 第一行段落 第二行段落 在一行的末尾加两个空格后按回车，可以实现换行。 12第一行 第二行 第一行 第二行 Markdown 强调语法 markdown 语言中使用星号 “*” 实现粗体和斜体。 要以斜体展示一段文字需要在文字两端加一对星号 “*” ，如 “*[内容]*”。 要加粗展示一段文字需要在文字两端加两对星号 “*” ，如 “**[内容]**”。 如果要对一段文字同时进行加粗和斜体展示，则需要在文字两端加三对星号“*”，如“***[内容]***”。 12345**粗体文字** *斜体文字****粗体斜体文字*** 粗体文字 斜体文字 粗体斜体文字 Markdown 引用语法 Markdown 语言通过在文字前加上小于号 “&gt;” 可以实现对一段文字进行块引用。如果需要对多段文字进行引用，怎需要在每一段文字的开头都加上小于号 “&gt;” 。 1&gt; 即使跌倒一百次，也要一百零一次地站起来。 即使跌倒一百次，也要一百零一次地站起来。 Markdown 语言还可以通过多个大于号实现多层引用（如果高层引用直接接上底层引用可能会无法正常显示）。 1234567&gt; 外层引用&gt;&gt; 中层引用&gt;&gt;&gt; 里层引用&gt;&gt;&gt;&gt; 中层引用&gt;&gt; 外层引用 Markdown 列表语法 如果 Markdown 语言中可实现类似于 html 语言的有序列表和无序列表。有序列表需要在段落前加数字和点“.”来表示，如 “1. [内容]” 。 1234561. 第一点2. 第二点3. 第三点 1. 插入第一点 2. 插入第二点4. 第四点 第一点 第二点 第三点 插入第一点 插入第二点 第四点 无序列表可以通过在段落前添加加号 “+” ，减号 “-” ，星号 “*” 中的任意一个来表示无序列表。通过灵活使用三者可以实现列表嵌套。 123456- 第一点- 第二点- 第三点 * 插入 * 插入- 第四点 第一点 第二点 第三点 插入 插入 第四点 Markdown 代码语法 在 Markdown 语言中，如果需要用段落表示代码，可以将其包裹在反引号 (`) 中。如果代码中含有单引号，可以将代码包含于两对单引号中。 1` print(&quot;hello world!&quot;) ` print(&quot;hello world!&quot;) 可以用三组反引号表示代码块，在最开始的三反引号后面写上对应的语言，在一些解释器中可以实现代码高亮表示。 123``` Pythonprint(&quot;hello world&quot;)``` 1print(&quot;hello world&quot;) Markdown 链接语法 类似于 html 中的超链接，Markdown 的超链接语法格式为 [超链接显示内容](地址 “超链接鼠标悬浮显示的标题”) 。 1[Jesse的个人博客](/) Jesse的个人博客 Markdown 图片语法 类似于 html 中的 img 标签，Markdown 的图片语法格式为 ![无法正常显示时的内容](地址 “超链接鼠标悬浮显示的标题”) ，与链接语法不同的是中括号前面要加上感叹号 “!” 。 1&#123;% image /images/covers/markdown-syntax-language.png %&#125; Markdown 转义字符语法 由于一些字符在 Markdown 语言中有具体的作用，为了在段落中能够使用这些字符，需要对字符进行转义。下面展示了所有需要在字符前加上反斜杠 “\\” 来对文字进行转义的字符。 \\\t`\t*\t_\t{}\t[]\t() # + - . ! | 1\\\\ \\` \\* \\_\t\\&#123;\\&#125;\t\\[\\]\t\\(\\)\t\\# \\+ \\- \\. \\! \\| \\\t` * _ {}\t[]\t()\t# + - . ! | 此外，由于 html 语言内部特性，，小于号“&lt;”和并号“&amp;”不能通过反斜杠 “\\”进行转义，必须要使用&amp;lt; 和 &amp;amp;对这两个字符进行转义(其他ASCII字符也可以通过这种方式进行转义)。 1&amp;amp; &amp;lt; &amp; &lt; Markdown 内嵌 HTML 标签 由于 Markdown 语言是HTML语言的简单表示形式，如果需要使用一些 HTML 中存在而 Markdown 中没有收录的 HTML 标签，或者需要通过 HTML 语言在 Markdown 文档中实现复杂的效果，如表格&lt;table&gt;标签，需要嵌入相应的 HTML 标签，直接在需要使用标签的位置嵌入即可。 123456789101112131415161718192021&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;列标题1&lt;/th&gt; &lt;th&gt;列标题2&lt;/th&gt; &lt;th&gt;列标题3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;行1，列1&lt;/td&gt; &lt;td&gt;行1，列2&lt;/td&gt; &lt;td&gt;行1，列3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2，列1&lt;/td&gt; &lt;td&gt;行2，列2&lt;/td&gt; &lt;td&gt;行2，列3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 列标题1 列标题2 列标题3 行1，列1 行1，列2 行1，列3 行2，列1 行2，列2 行2，列3 如果需要在 Markdown 文档中使用注释，也可以使用 HTML 的注释格式&lt;!-- --&gt;来表示。 12345我不是注释&lt;!-- 我是注释 --&gt;我不是注释 我不是注释 我不是注释","tags":["Markdown"],"categories":["技术小屋","Markdown"]},{"title":"博客建设日志","path":"/posts/3847924491/","content":"网站建设历史 2023-11-26 通过 Hexo 的 Chic 主题完成网站搭建，上传了第一篇文章。 2023-11-27 改用 Hexo 的 Stellar 主题，完成了博客的 about 部分。 2023-12-01 创建博客建设日志。 2023-12-03 创建分类目录，创建博客的五种分类。 2023-12-08 将网站最初的日记目录更改为 abbr 目录，防止未来出现死链；将解释器从 pandoc 改为 renderer-markdown-it 。 网站建设心路 2023-12-08 最开始我建这个网站觉得只要建好了就很容易写文章了，但我却不愿意写不太全面的，也不太知道些什么，都过了半个月了博客里面还是空空的，只有一些我自己类似于学习笔记的东西，其他的大概都布置的差不多了。船舰这个博客的过程中我遇到了好多问题，大多数都要么解决了，要么还在留着，要么藏起来了。其实这个博客的搭建到完善只是一个过程，等我大学毕业之后~ 如果 JS 的东西学的还不错的话 ~会自己去找一个服务器，从 HTML 开始一点一点搭建一整个博客，这是我学前端最早的目标，虽然很难但我也应该坚持。也许我只是太闲了没事干吧。 网站建设未解决的问题 头像 因为有一个博客，所以也想要设计一个头像。头像我打算找时间设计一个独特一点的，因为还没有真的动手去做，所以不知道做好是什么样的呢，总之先留着吧。 动态网站因为 GitHub 上好像只能写 1 GB 的文件，所以我要是一直这么加东西的话早晚会有网站过大的一天。而且是 GitHub 上部署的文件没有数据库，所以没办法获得访问者的数量、情报、评论什么的，因此现在看来或许我可以把我的文章多在这上面存着，但这不是什么长久的计策。我大学毕业前要是一直能用的话就等到大学毕业再试着改成动态网站吧。虽然动态网站对我来说实在是太难搞了，但一点一点学总会有进步的。 社交 因为我暂时没有能够分享博客的朋友，所以无论是留言板还是友链都是空的，会跳转到 404 。我觉得这个博客还没发展到可以直接分享，还需要更多文章撑起来内容，所以这些以后再研究吧。","tags":["博客维护"],"categories":["博客维护"]},{"title":"about","path":"/about/index.html","content":"欢迎来到 JesseZG 的小破站！博主是测控专业大二学生，爱好编程和游戏，在博客上记录一些生活学习经历如果对博主或博主的小站感兴趣欢迎通过邮箱z12502793@163.com交流(ᕑᗢᓫ∗)˒"},{"title":"作品廊","path":"/categories/技术小屋/index.html","content":"欢迎来到程序设计！"},{"title":"friends","path":"/friends/index.html","content":"博主目前没有朋友 (っ◞‸◟c) 如果想要博主在这个小破站的友链里附上链接的话可以私发 z12502793@163.com 邮箱，博主会考虑加到这里(✧∇✧)"},{"title":"作品廊","path":"/categories/回忆录/index.html","content":"欢迎来到欢迎来到回忆录！"},{"title":"作品廊","path":"/categories/作品廊/index.html","content":"欢迎来到作品廊！"},{"title":"作品廊","path":"/categories/学习笔记/index.html","content":"欢迎来到学习笔记！"},{"title":"作品廊","path":"/categories/博客维护/index.html","content":"欢迎来到博客维护！"}]