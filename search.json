[{"title":"【Python】Python 数据结构与算法笔记","path":"/posts/2669252520/","content":"前言 Python 学了很久，因为要准备 Python 的比赛和考试，所以就写了这一篇文章整理一下 Python 数据结构和算法方面的东西。 线性数据结构 元素被加入进来之后，与前后元素的相对位置保持不变的数据结构就是线性结构，主要包括栈、队列、双端队列、列表四种。 Python 并不能直接支持这些数据结构，我认为学习这些结构是为了能够在以后的算法中能够有一些思路，能更方便的解决问题，在 Python 中可以通过 pythonds.basic 包获得对应的类名。 栈 栈的添加操作和删除操作在结构的同一端，简单的说就是先进先出，LIFO，就像是一堆盘子，放在上面的也最先拿走。 需要支持的方法包括： push(item)，将一个元素添加到站的顶端，需要一个参数 push，没有返回值； pop()，将一个栈顶端的元素弹出，返回弹出的元素； peek()，返回顶端的元素，但不弹出； isEmpty()，检测栈是否为空，返回布尔值； size()，返回栈中元素的数目，返回一个整数。 括号匹配问题 在数学表达式中，可能会出现很多括号，可以通过栈来解决括号的匹配问题。","tags":["python","算法"],"categories":["技术小屋","Python"]},{"title":"【Python】Python + Scipy + Matplotlib 实现任意一元函数拟合","path":"/posts/3950149617/","content":"前言 之前在大学组织里面参加校内举办的智能汽车竞赛，顺便用 Python 研究了下一元函数拟合。虽然没用到，但闲着没事的时候用 Tkinter 封装好了程序。本文大致介绍一些程序设计的思路，因为文件太大不适合在 Github 上部署，所以在最后附上了源代码。因为博主是 Python 初学者，所以无论是算法方面还是逻辑方面可能都会有可以优化的地方，有建议可以通过邮箱 z12502793@163.com 反馈。 工具介绍 Python Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，具有良好的可移植性和可扩展性，最初被设计用于编写自动化脚本(shell)。随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发，在科学计算、人工智能、Web开发、网络爬虫、数据分析等领域都有广泛的应用。 Numpy 和 Scipy Numpy 和 Scipy 是Python的两个科学计算库。Numpy 提供了数组对象，以及许多用于操作这些数组的函数；Scipy 是一个用于科学计算的 Python 库，它包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。Numpy 和 Scipy 的协同工作可以高效解决很多问题，在人工智能、数据分析等众多领域中得到了广泛应用。 Matplotlib 和 Pyplot Matplotlib 是 Python 的一个绘图库，它能提供多样化的输出格式实现数据可视化。Pyplot 是 Matplotlib 的子库，提供了和 MATLAB 类似的绘图API，是 Python 常用的绘图模块，能很方便绘制函数图像或统计图。 Tkinter Tkinter 提供了多种控件，如按钮，标签，文本框等，以及标准属性和方法，如大小，颜色，字体等，是Python的标准Tk GUI工具包的接口。 代码 没有用 Tkinter 打包的拟合原代码 123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, b, c): return b*x + c# 输入要拟合的x,y的值的原始数据x = np.array([600,700, 800, 900,1000,1100,1200,1300,1400])y = np.array([800,900,1000,1100,1200,1200,1300,1400,1490])#进行函数拟合,abcd为输出函数参数，para为拟合效果参数abcd, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(abcd)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)# 后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况predict_past = 100predict_future = 100#将拟合的函数转换成函数图像微分形式X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000)Y = f(X, *abcd)#绘制拟合前数据点图效果和拟合后函数图像效果fig, ax = plt.subplots()ax.set_title(&quot;function fitting curve&quot;)ax.set_xlabel(&quot;right_speed&quot;)ax.set_ylabel(&quot;left_speed&quot;)ax.scatter(x, y)ax.plot(X, Y, color=&quot;r&quot;)plt.show() Tkinter 封装后的代码 使用方法 在 Python 环境下运行文件，在第一行中选择要拟合的变量数，第二行输入要拟合成的函数表达式（表达式为函数x侧的多项式，用 Python 数学表达式的方法表示，参数从 a 开始，数量要与要拟合的参数数保持对应；例如要拟合的函数为普通二次函数,应输入ax**2+bx+c）。 第三、四行输入要拟合的 x, y 变量的原始值，必须要一一对应，数量不能少于拟合参数数量，两个数字之间用逗号分隔。 第五行输入拟合效果图像中变量 x, y 多余的范围，例如如果要拟合二次函数输入的 x 的初始值为 1, 2, 3; 输入的 y 的初始值为 1, 4, 9; 如果需要查看图像x，y的范围均为1，则展示拟合曲线在 x=[0,4] 范围的二次曲线。如果不需要则都应该写成0,不写程序会报错。 第六行点击后即可执行程序，在右边会出现拟合函数图像，下面会出现很多个参数，依次是 a, b, c… 的拟合参数。 如果程序报错提示找不到 Numpy, Scipy, Tkinter, Matplotlib 等第三方库则需要在终端中输入 pip install 【需要的模块名】 下载对应模块。 其他报错可能是输入的问题，检查是否严格按照此处所写的使用方法执行。如果未能发现问题可以向邮箱 z12502793@163.com 进行反馈。博主只是一个爱好编程的大学生，如果发现其他 bug、优化方案也可以通过邮箱向博主提建议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186import tkinter as tkfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAggimport matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as opimport sys# 定义拟合函数，每种对应一种参数数量def f1(x, a): return eval(entry1.get())def f2(x, a, b): return eval(entry1.get())def f3(x, a, b, c): return eval(entry1.get())def f4(x, a, b, c, d): return eval(entry1.get())def f5(x, a, b, c, d, e): return eval(entry1.get())def f6(x, a, b, c, d, e, f): return eval(entry1.get())def f7(x, a, b, c, d, e, f, g): return eval(entry1.get())def f8(x, a, b, c, d, e, f, g, h): return eval(entry1.get())# 按下按钮后执行def start(): # 清除画布上所有东西 for widget in frame_canva.winfo_children(): widget.destroy() # 要拟合的x,y的值的原始数据 x = eval(&quot;np.array([&quot; + entry2.get() + &quot;])&quot;) y = eval(&quot;np.array([&quot; + entry3.get() + &quot;])&quot;) #对每一种参数数量进行函数拟合,abcd为输出函数参数，para为拟合效果参数 if radio_value.get() == 1: abcd, para = op.curve_fit(f1, x, y) if radio_value.get() == 2: abcd, para = op.curve_fit(f2, x, y) if radio_value.get() == 3: abcd, para = op.curve_fit(f3, x, y) if radio_value.get() == 4: abcd, para = op.curve_fit(f4, x, y) if radio_value.get() == 5: abcd, para = op.curve_fit(f5, x, y) if radio_value.get() == 6: abcd, para = op.curve_fit(f6, x, y) if radio_value.get() == 7: abcd, para = op.curve_fit(f7, x, y) if radio_value.get() == 8: abcd, para = op.curve_fit(f8, x, y) # 将abcd打印出来替换原来的text6 text6 = tk.Label(frame_value, text=abcd) text6.grid(row=9, column=0, columnspan=2) # 后面都是用来看拟合图像效果的 #这个两参数用于预测拟合图像在给的值之前和之后的发展情况 predict_past = eval(&quot;np.array(&quot; + entry4.get() + &quot;)&quot;) predict_future = eval(&quot;np.array(&quot; + entry5.get() + &quot;)&quot;) #将拟合的函数转换成函数图像微分形式 X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000) if radio_value.get() == 1: Y = f1(X, *abcd) if radio_value.get() == 2: Y = f2(X, *abcd) if radio_value.get() == 3: Y = f3(X, *abcd) if radio_value.get() == 4: Y = f4(X, *abcd) if radio_value.get() == 5: Y = f5(X, *abcd) if radio_value.get() == 6: Y = f6(X, *abcd) if radio_value.get() == 7: Y = f7(X, *abcd) if radio_value.get() == 8: Y = f8(X, *abcd) #绘制拟合前数据点图效果和拟合后函数图像效果# --------------------------------------------------------# 这段是画图像的，但不知道具体在干嘛，以后可以研究研究 fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例 f_plot =fig.add_subplot(111)#划分区域 canvas = FigureCanvasTkAgg(fig,frame_canva) canvas.get_tk_widget().pack()#放置位置 plt.scatter(x, y) plt.plot(X, Y, color=&quot;r&quot;)# -------------------------------------------------------# 创建窗口window = tk.Tk()window.title(&quot;Fitting_curve&quot;)#定义四个框架，其中radio和value框架在frame里面，canva与frame并列frame = tk.Frame(window, width=150, height=80, borderwidth=5)frame_radio = tk.Frame(frame, width=150, height=80, borderwidth=5)frame_value = tk.Frame(frame, width=150, height=300, borderwidth=5)frame_canva = tk.Frame(window, width=150, height=400, borderwidth=5)# 定义radio框架中的内容text0 = tk.Label(frame_radio, text=&quot;参量数：&quot;)radio_value = tk.IntVar()radio1 = tk.Radiobutton(frame_radio, text=1, value=1, variable=radio_value)radio2 = tk.Radiobutton(frame_radio, text=2, value=2, variable=radio_value)radio3 = tk.Radiobutton(frame_radio, text=3, value=3, variable=radio_value)radio4 = tk.Radiobutton(frame_radio, text=4, value=4, variable=radio_value)radio5 = tk.Radiobutton(frame_radio, text=5, value=5, variable=radio_value)radio6 = tk.Radiobutton(frame_radio, text=6, value=6, variable=radio_value)radio7 = tk.Radiobutton(frame_radio, text=7, value=7, variable=radio_value)radio8 = tk.Radiobutton(frame_radio, text=8, value=8, variable=radio_value)#定义value框架中的内容text1 = tk.Label(frame_value, text=&quot;输入要拟合成的函数表达式&quot;)entry1 = tk.Entry(frame_value, width= 50)text2 = tk.Label(frame_value, text=&quot;输入要拟合的x变量&quot;)entry2 = tk.Entry(frame_value, width= 50)text3 = tk.Label(frame_value, text=&quot;输入要拟合的y变量&quot;)entry3 = tk.Entry(frame_value, width= 50)text4 = tk.Label(frame_value, text=&quot;输入要预测的x变量范围&quot;)entry4 = tk.Entry(frame_value, width= 25)text5 = tk.Label(frame_value, text=&quot;输入要预测的y变量范围&quot;)entry5 = tk.Entry(frame_value, width= 25)text6 = tk.Label(frame_value, text=&quot;&quot;)button = tk.Button(frame_value, text=&quot;开始拟合&quot;, command=start, pady=3)# 将radio和value一依次放在frame的上面frame_radio.pack(side=&quot;top&quot;)frame_value.pack(side=&quot;top&quot;)# 将radio中的东西用grid放置text0.grid(row=0, column=0)radio1.grid(row=0, column=1)radio2.grid(row=0, column=2)radio3.grid(row=0, column=3)radio4.grid(row=0, column=4)radio5.grid(row=0, column=5)radio6.grid(row=0, column=6)radio7.grid(row=0, column=7)radio8.grid(row=0, column=8)# 将value中的东西用grid放置text1.grid(row=0, column=0, columnspan=2)entry1.grid(row=1, column=0, columnspan=2,)text2.grid(row=2, column=0, columnspan=2)entry2.grid(row=3, column=0, columnspan=2)text3.grid(row=4, column=0, columnspan=2)entry3.grid(row=5, column=0, columnspan=2)text4.grid(row=6, column=0)entry4.grid(row=7, column=0)text5.grid(row=6, column=1)entry5.grid(row=7, column=1)text6.grid(row=9, column=0, columnspan=2)button.grid(row=8, column=0, columnspan=2)# 将frame和canva两个框架依次放在左边frame.pack(side=&quot;left&quot;)frame_canva.pack(side=&quot;left&quot;)# 在刚打开文件时还没有图像，这一段用来在刚打开文件时放一个图像fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例f_plot =fig.add_subplot(111)#划分区域canvas = FigureCanvasTkAgg(fig,frame_canva)canvas.get_tk_widget().pack()#放置位置# 监测是否关掉窗口，关掉后结束程序window.protocol(&quot;WM_DELETE_WINDOW&quot;, lambda: sys.exit())# 主循环window.mainloop() 研究用：二元函数拟合 这个程序是博主和 Chatgpt 搞了一整天才实现的，依旧是通过 Scipy.optimize 实现二次函数拟合。程序中很多地方博主依旧不明白是怎么实现的，但是因为勉强可以用所以也发到这篇文章中了。这个程序还在研发中所以可能有很多 Bug，如果发现可以修改的地方可以通过邮箱z12502793@163.com 告诉博主。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, a, b, c, d, e): return a*x[0]**2 + b*x[0] + c*x[1]**2 + d*x[1] + e# 输入要拟合的x1, x2, y的值的原始数据, x1的格式与y横行长度相同，x2的格式与y竖行长度相同x1 = (1, 2, 3, 4, 5, 6)x2 = (1, 2, 3, 4, 5)y = np.array([[3, 10, 21, 36, 55, 78], [4, 11, 22, 37, 56, 79], [5, 12, 23, 38, 57, 80], [6, 13, 24, 39, 58, 81], [7, 14, 25, 40, 59, 82]])# x1, x2, y整理形式进行函数拟合x1, x2 = np.meshgrid(x1, x2)x = np.vstack((x1.flatten(), x2.flatten()))y = y.flatten()abc, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(*abc)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)#后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况x1_past = 3x1_future = 3x2_past = 3x2_future = 3# #将拟合的函数转换成函数图像微分形式X1 = np.linspace(x1[0, 0] - x1_past, x1[0, -1] + x1_future, 101) # 创建非周期性网格X2 = np.linspace(x2[0, 0] - x2_past, x2[-1, 0] + x2_future, 101) # 创建非周期性网格X = np.meshgrid(X1, X2)Y = (f(X, *abc))#绘制拟合前数据点图效果和拟合后函数图像效果ax = plt.subplot(projection=&quot;3d&quot;)ax.scatter(x[0], x[1], y, color=&quot;black&quot;)ax.plot_surface(X[0], X[1], Y, cmap=&quot;rainbow&quot;)ax.set_xlabel(&quot;x1&quot;)ax.set_ylabel(&quot;x2&quot;)ax.set_zlabel(&quot;y&quot;)plt.show()","tags":["数学","Python"],"categories":["技术小屋","Python"]},{"title":"【Markdown】Markdown 语言基础语法","path":"/posts/913170794/","content":"前言 很早之前学 html 的时候就认识了 Markdown 语言，但当时对 Markdown 的理解就是 html 的简化版，所以学了也很快就忘记了。最近因为要写博客，所以顺便学习了 Markdown 的基本知识，对Markdown 文本有了更深的了解，所以写了这么一篇文章来回忆总结一下 Markdown 的基本语法和规范。 Markdown 语言介绍 Markdown是一种标记语言，排版语法非常简洁，使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。 Markdown 语言的基本语法 我认为 Markdown 就是一个更方便书写的，能够用 html 表示的一种简约的标记语言， Markdown 标记之后的文章具有比 html 更强大的可读性，而且也不需要像 Word 一样的排版和缩进，通过使用 Markdown 在不严重破坏 html 的同时增进代码中文本书写的速度。 Markdown 标题语法 Markdown 的标题是通过井号 “#” 实现的，实现方法就是多少个标题就写多少个 “#” 。井号后面要加一个空格，然后写后面的内容比如三级标题就要输入“### [内容]”。 井号越少越高级，通常一个井号代表文章标题，两个个井号代表大节，三个井号代表大节下的小标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一、二级标题可以用等号 “=” 和减号 “-” ，方法是在要输入的标题下面输入任意数量的等号或减号。 12345一级标题===二级标题--- 此外，在 Markdown 语言中，在一行中的连续三个星号“*”,破折号“-”，下划线“_”，可以实现分割线的作用。（可以在符号中间插入空格）。 123456***---___ Markdown 段落换行语法 Markdown中没有专用的换行符，创建段落就需要在两段话之间加入一个空行。 123第一行段落第二行段落 第一行段落 第二行段落 在一行的末尾加两个空格后按回车，可以实现换行。 12第一行 第二行 第一行 第二行 Markdown 强调语法 markdown 语言中使用星号 “*” 实现粗体和斜体。 要以斜体展示一段文字需要在文字两端加一对星号 “*” ，如 “*[内容]*”。 要加粗展示一段文字需要在文字两端加两对星号 “*” ，如 “**[内容]**”。 如果要对一段文字同时进行加粗和斜体展示，则需要在文字两端加三对星号“*”，如“***[内容]***”。 12345**粗体文字** *斜体文字****粗体斜体文字*** 粗体文字 斜体文字 粗体斜体文字 Markdown 引用语法 Markdown 语言通过在文字前加上小于号 “&gt;” 可以实现对一段文字进行块引用。如果需要对多段文字进行引用，怎需要在每一段文字的开头都加上小于号 “&gt;” 。 1&gt; 即使跌倒一百次，也要一百零一次地站起来。 即使跌倒一百次，也要一百零一次地站起来。 Markdown 语言还可以通过多个大于号实现多层引用（如果高层引用直接接上底层引用可能会无法正常显示）。 1234567&gt; 外层引用&gt;&gt; 中层引用&gt;&gt;&gt; 里层引用&gt;&gt;&gt;&gt; 中层引用&gt;&gt; 外层引用 Markdown 列表语法 如果 Markdown 语言中可实现类似于 html 语言的有序列表和无序列表。有序列表需要在段落前加数字和点“.”来表示，如 “1. [内容]” 。 1234561. 第一点2. 第二点3. 第三点 1. 插入第一点 2. 插入第二点4. 第四点 第一点 第二点 第三点 插入第一点 插入第二点 第四点 无序列表可以通过在段落前添加加号 “+” ，减号 “-” ，星号 “*” 中的任意一个来表示无序列表。通过灵活使用三者可以实现列表嵌套。 123456- 第一点- 第二点- 第三点 * 插入 * 插入- 第四点 第一点 第二点 第三点 插入 插入 第四点 Markdown 代码语法 在 Markdown 语言中，如果需要用段落表示代码，可以将其包裹在反引号 (`) 中。如果代码中含有单引号，可以将代码包含于两对单引号中。 1` print(&quot;hello world!&quot;) ` print(&quot;hello world!&quot;) 可以用三组反引号表示代码块，在最开始的三反引号后面写上对应的语言，在一些解释器中可以实现代码高亮表示。 123``` Pythonprint(&quot;hello world&quot;)``` 1print(&quot;hello world&quot;) Markdown 链接语法 类似于 html 中的超链接，Markdown 的超链接语法格式为 [超链接显示内容](地址 “超链接鼠标悬浮显示的标题”) 。 1[Jesse的个人博客](/) Jesse的个人博客 Markdown 图片语法 类似于 html 中的 img 标签，Markdown 的图片语法格式为 ![无法正常显示时的内容](地址 “超链接鼠标悬浮显示的标题”) ，与链接语法不同的是中括号前面要加上感叹号 “!” 。 1&#123;% image /images/covers/markdown-syntax-language.png %&#125; Markdown 转义字符语法 由于一些字符在 Markdown 语言中有具体的作用，为了在段落中能够使用这些字符，需要对字符进行转义。下面展示了所有需要在字符前加上反斜杠 “\\” 来对文字进行转义的字符。 \\\t`\t*\t_\t{}\t[]\t() # + - . ! | 1\\\\ \\` \\* \\_\t\\&#123;\\&#125;\t\\[\\]\t\\(\\)\t\\# \\+ \\- \\. \\! \\| \\\t` * _ {}\t[]\t()\t# + - . ! | 此外，由于 html 语言内部特性，，小于号“&lt;”和并号“&amp;”不能通过反斜杠 “\\”进行转义，必须要使用&amp;lt; 和 &amp;amp;对这两个字符进行转义(其他ASCII字符也可以通过这种方式进行转义)。 1&amp;amp; &amp;lt; &amp; &lt; Markdown 内嵌 HTML 标签 由于 Markdown 语言是HTML语言的简单表示形式，如果需要使用一些 HTML 中存在而 Markdown 中没有收录的 HTML 标签，或者需要通过 HTML 语言在 Markdown 文档中实现复杂的效果，如表格&lt;table&gt;标签，需要嵌入相应的 HTML 标签，直接在需要使用标签的位置嵌入即可。 123456789101112131415161718192021&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;列标题1&lt;/th&gt; &lt;th&gt;列标题2&lt;/th&gt; &lt;th&gt;列标题3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;行1，列1&lt;/td&gt; &lt;td&gt;行1，列2&lt;/td&gt; &lt;td&gt;行1，列3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2，列1&lt;/td&gt; &lt;td&gt;行2，列2&lt;/td&gt; &lt;td&gt;行2，列3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 列标题1 列标题2 列标题3 行1，列1 行1，列2 行1，列3 行2，列1 行2，列2 行2，列3 如果需要在 Markdown 文档中使用注释，也可以使用 HTML 的注释格式&lt;!-- --&gt;来表示。 12345我不是注释&lt;!-- 我是注释 --&gt;我不是注释 我不是注释 我不是注释 hexo-renderer-markdown-it 介绍 hexo-renderer-markdown-it 式一个 hexo 的 Markdown 解释器，因为 Markdown 解释器众多，仅仅是在细节上有差别，所以正常使用的话用哪个都差不多，但如果需要进行数学表达式等就需要考虑解释器的问题了。博主使用 hexo-renderer-markdown-it，支持 MathJax（适配不是很好，需要调整），可以使用类似于 GFM 的所有功能，还有一些 hexo-renderer-markdown-it 独有的功能，下面对 hexo-renderer-markdown-it 的附增 Markdown 语法做一个研究和介绍。 hexo-renderer-markdown-it 语法 hexo-renderer-markdown-it 表格语法 在 hexo-renderer-markdown-it 中，可以通过连字符和“-”，通道符号“|”两个符号围成表格，来代替原本 Markdown 语言中的表格标签（GFM 语法也可以实现）。表格尺寸可以自定义，表头与表格体用对应的多个连词符分开。 1234| 列标题一 | 列标题二 | 列标题三 | | --- | --- | --- || 行1，列1 | 行1，列2 | 行1，列3 | | 行2，列1 | 行2，列2 | 行2，列3 | 列标题一 列标题二 列标题三 行1，列1 行1，列2 行1，列3 行2，列1 行2，列2 行2，列3 hexo-renderer-markdown-it 删除线语法 hexo-renderer-markdown-it 中任意两对双波浪线 “ ~~ ”,可以实现删除线的效果，即 HTML 中的 &lt;del&gt; 标签（GFM 中也可以实现）。 1~~del~~ del 注：单词两端不能加空格 ###hexo-renderer-markdown-it Emoji表情语法 hexo-renderer-markdown-it 中，可以通过在两端写上冒号 “:” 来表示 Emoji 表情（在 GFM 中也可以实现）。 1234:grinning::heart_eyes::speech_balloon::peach: 😀 😍 💬 🍑 这些表情有很多，和 HTML 标签混合可以实现很多有趣的效果。可以在github官方表情中查找对应表情的编码。 hexo-renderer-markdown-it 任务列表项语法 hexo-renderer-markdown-it 中，可以通过类似于无序列表，在加号 “+” ，连词符 “-” 或星号 “*” 后面加上空格中括号[ ]或者 “x” 中括号[x]来实现任务列表项。填写列表项后对应的 Markdown 源代码也会发生改变。（GFM 也可以实现） 1234- [ ] 待办事项1- [ ] 待办事项2- [x] 待办事项3- [ ] 待办事项4 待办事项1 待办事项2 待办事项3 待办事项4 hexo-renderer-markdown-it 上下标语法 hexo-renderer-markdown-it 通过在内容两边加上“^”表示上标，加上“~”表示下标（无法共同表示）。 1x^2^~1~+x^2^~2~ = 1 x21 + x22 = 1 hexo-renderer-markdown-it 标记下划线语法 hexo-renderer-markdown-it 通过在内容两边加上两个等号“==”表示标记，加两个加号“++”表示下划线。 12==标记==++下划线++ 标记下划线 自动链接语法 hexo-renderer-markdown-it 中，可以在文件中写域名或网站，会直接变成一个链接。 www.bing.com z12502793@163.com hexo-renderer-markdown-it 折叠 在一段文字前后加上三个加号“+++”可以实现折叠功能,折叠前的文字用前后各两个星号“*”包围。 123+++ **展开**隐藏内容+++ &nbsp;展开隐藏内容 自定义容器 可以实现自定义容器（大概大概为设置 div 盒子中的 id），在 hexo 或其他网站的 css 中添加即可自定义容器，使用的方法为在段落前后加上三个冒号，第一段空格加上 容器的 id 名即可实现自定义容器，下面是四个例子。 12345678910111213141516171819::: tips**提示**这是一个提示:::::: warning**注意**这是一个警告:::::: danger**警告**这是一个危险信号:::::: success**成功**这是一个成功信号::: 提示 这是一个提示 注意 这是一个警告 警告 这是一个危险信号 成功 这是一个成功信号","tags":["Markdown"],"categories":["技术小屋","Markdown"]},{"title":"【博客维护】博客建设日志","path":"/posts/3847924491/","content":"网站建设历史 2023-11-26 通过 Hexo 的 Chic 主题完成网站搭建，上传了第一篇文章。 2023-11-27 改用 Hexo 的 Stellar 主题，完成了博客的 about 部分。 2023-12-01 创建博客建设日志。 2023-12-03 创建分类目录，创建博客的五种分类。 2023-12-08 将网站最初的日记目录更改为 abbr 目录，防止未来出现死链；将解释器从 pandoc 改为 renderer-markdown-it。 2023-12-08 修改了网站的 css，加上了 id 为 tips, success, warning, danger 的样式，用于自定义盒子。 2023-12-12 统一 Markdown 文档的文件格式 网站建设心路 2023-12-08 最开始我建这个网站觉得只要建好了就很容易写文章了，但我却不愿意写不太全面的，也不太知道些什么，都过了半个月了博客里面还是空空的，只有一些我自己类似于学习笔记的东西，其他的大概都布置的差不多了。船舰这个博客的过程中我遇到了好多问题，大多数都要么解决了，要么还在留着，要么藏起来了。其实这个博客的搭建到完善只是一个过程，等我大学毕业之后~ 如果 JS 的东西学的还不错的话 ~会自己去找一个服务器，从 HTML 开始一点一点搭建一整个博客，这是我学前端最早的目标，虽然很难但我也应该坚持。也许我只是太闲了没事干吧。 网站建设未解决的问题 头像 因为有一个博客，所以也想要设计一个头像。头像我打算找时间设计一个独特一点的，因为还没有真的动手去做，所以不知道做好是什么样的呢，总之先留着吧。 动态网站因为 GitHub 上好像只能写 1 GB 的文件，所以我要是一直这么加东西的话早晚会有网站过大的一天。而且是 GitHub 上部署的文件没有数据库，所以没办法获得访问者的数量、情报、评论什么的，因此现在看来或许我可以把我的文章多在这上面存着，但这不是什么长久的计策。我大学毕业前要是一直能用的话就等到大学毕业再试着改成动态网站吧。虽然动态网站对我来说实在是太难搞了，但一点一点学总会有进步的。 社交 因为我暂时没有能够分享博客的朋友，所以无论是留言板还是友链都是空的，会跳转到 404 。我觉得这个博客还没发展到可以直接分享，还需要更多文章撑起来内容，所以这些以后再弄吧。","tags":["博客维护"],"categories":["博客维护"]},{"title":"about","path":"/about/index.html","content":"有关博客 欢迎来到 JesseZG 的小破站！本站由 Hexo 的 stellar 制作搭建于 GitHub 上，在博客中记录一些学习生活经历， 博客维护：这个栏目会记录一些博客建立历程和博主的创作心路； 技术小屋：这个栏目中会有博主在计算机各领域学习的笔记和研究； 学习笔记：这个栏目中会有博主大学课程中数学物理硬件方面的学习笔记； 回忆录：这个栏目用来整理博主玩过的游戏，看过的电影，读过的书，作为回忆珍藏在这里； 作品廊：这个栏目中会有作者的一些艺术文学和程序创作，博主制作的完整作品也会放在这个栏目中。 虽然这个小站还是很穷，但博主会一点一点地让这里富裕起来的(ᕑᗢᓫ∗)˒ 有关博主 博主是测控专业的大二学生，喜欢学习新东西，因此爱好广泛但都不深入，喜欢打游戏看电影画画写小说学编程…… 如果对博主的小站感兴趣欢迎通过邮箱z12502793@163.com交流(⑅˃◡˂⑅)。"},{"title":"friends","path":"/friends/index.html","content":"博主目前没有朋友 (っ◞‸◟c) 如果想要博主在这个小破站的友链里附上链接的话可以私发 z12502793@163.com 邮箱，博主会考虑加到这里(✧∇✧)"},{"title":"作品廊","path":"/categories/作品廊/index.html","content":"欢迎来到作品廊！"},{"title":"作品廊","path":"/categories/博客维护/index.html","content":"欢迎来到博客维护！"},{"title":"作品廊","path":"/categories/学习笔记/index.html","content":"欢迎来到学习笔记！"},{"title":"作品廊","path":"/categories/回忆录/index.html","content":"欢迎来到欢迎来到回忆录！"},{"title":"作品廊","path":"/categories/技术小屋/index.html","content":"欢迎来到程序设计！"}]